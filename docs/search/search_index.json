{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to JAWT So you're here to check out JAWT. Awesome. In a nutshell, JAWT is a toolchain for building web apps in a more straightforward, declarative way. I got tired of the endless setup and complexity that comes with modern web development, so I built JAWT around a simple idea: you should be able to describe your application's structure and logic, and the tool should handle the rest. You'll be writing your apps using JML , a language I designed specifically for this, and TypeScript for all the dynamic bits. What's Jawt All About? Instead of wrestling with bundlers, transpilers, and a million config files, Jawt gives you a single, unified workflow. You write JML for structure, TypeScript for logic, and Jawt's compiler figures out how to turn it all into an optimised, fast web app. Here's the Gist: One Language for Structure : Use JML to lay out your pages and components. It's clean and easy to read. Component-Based Everything : Build your UI out of reusable components. It's a tried-and-true way to keep things organised. Zero-Config, but Hackable : It works right away with smart defaults, but you can still tweak things if you need to. Instant Feedback : The dev server comes with hot module replacement, so you see your changes live. Optimised by Default : It automatically handles things like code splitting and tree shaking to make sure your app is fast. Full-Fat TypeScript : No compromises. Use all the TypeScript features you know and love. How JML Works JML is the core of JAWT. Every JML file has a _doctype that tells the compiler what it is. There are two main types: _doctype page home // This is a whole web page. _doctype component Button // This is a reusable building block. Pages Pages are the main entry points of your app. They define a full web page with its metadata and structure. _doctype page dashboard import component Layout from \"components/layout\" Page { title: \"Dashboard - My App\" description: \"Application dashboard with analytics\" Layout { section: \"dashboard\" showSidebar: true } } Components Components are the reusable UI bits. You build them once and use them everywhere. _doctype component UserCard Container { style: \"bg-white shadow-md rounded-lg p-6\" Text { content: props.userName style: \"text-xl font-semibold text-gray-800\" } Button { text: \"View Profile\" onClick: () => navigateToProfile(props.userId) style: \"mt-4 bg-blue-500 text-white px-4 py-2 rounded\" } } Bringing in the Logic with TypeScript Jawt wouldn't be complete without a way to handle dynamic logic. That's where TypeScript comes in. You can write your functions and classes in .ts files and import them right into your JML. // scripts/analytics.ts export function trackPageView(page: string): void { // Analytics logic } export function trackUserAction(action: string, data?: any): void { // User interaction tracking } _doctype component Analytics import script analytics from \"scripts/analytics\" Container { onClick: () => analytics.trackUserAction(\"button_click\", { id: props.buttonId }) } The Workflow The jawt CLI is your best friend here. It's got everything you need: Start a new project: jawt init my-app Run the dev server: jawt run Build for production: jawt build Debug your app: jawt debug The compiler is smart enough to understand all the different document types and how they depend on each other, spitting out a nice, optimised app at the end. The Philosophy The idea behind Jawt's architecture is to keep things separate and clean: Pages for structure and routing. Components for UI and user interaction. Scripts for business logic and dynamic stuff. This makes your code easier to reason about and helps Jawt optimise how it loads everything. Quick Start Example Here's what a simple Jawt app looks like: my-app/ \u251c\u2500\u2500 app/ \u2502 \u251c\u2500\u2500 index.jml # Home page \u2502 \u2514\u2500\u2500 about/index.jml # About page \u251c\u2500\u2500 components/ \u2502 \u251c\u2500\u2500 layout.jml # Shared layout \u2502 \u2514\u2500\u2500 user-card.jml # Reusable component \u2514\u2500\u2500 scripts/ \u2514\u2500\u2500 analytics.ts # TypeScript functionality Page ( app/index.jml ): _doctype page home import component Layout from \"components/layout\" Page { title: \"Welcome to My App\" Layout { showWelcome: true } } Component ( components/layout.jml ): _doctype component Layout import script analytics from \"scripts/analytics\" Container { style: \"min-h-screen bg-gray-50\" Header { style: \"bg-white shadow-sm p-4\" if (props.showWelcome) { Text { content: \"Welcome!\" style: \"text-2xl font-bold\" } } } onClick: () => analytics.trackPageView(\"home\") } Script ( scripts/analytics.ts ): export function trackPageView(page: string): void { console.log(`Page view: ${page}`) // Analytics implementation } Browser Support Jawt spits out modern, standards-compliant code that works in all the usual suspects (Chrome, Firefox, Safari, Edge). It'll even add polyfills where needed. Where to Next? Ready to dive in? Getting Started Installation & Setup - Get Jawt installed and make your first project. Tutorial - Build a simple app from scratch. Project Structure - Learn how to organise your Jawt projects. Language Reference JML Syntax - The full JML language spec. Pages - All about creating pages and routes. Components - Master building interactive components. Scripts - Using TypeScript for dynamic functionality. Advanced Stuff Architecture - A peek under the hood. CLI Reference - A guide to all the CLI commands. Configuration - How to customise your build. Deployment - Getting your app out into the world. Resources Examples - Sample apps and code patterns. Migration Guide - Coming from another tool? FAQ - Answers to common questions. Contributing - Want to help out?","title":"Home"},{"location":"#welcome-to-jawt","text":"So you're here to check out JAWT. Awesome. In a nutshell, JAWT is a toolchain for building web apps in a more straightforward, declarative way. I got tired of the endless setup and complexity that comes with modern web development, so I built JAWT around a simple idea: you should be able to describe your application's structure and logic, and the tool should handle the rest. You'll be writing your apps using JML , a language I designed specifically for this, and TypeScript for all the dynamic bits.","title":"Welcome to JAWT"},{"location":"#whats-jawt-all-about","text":"Instead of wrestling with bundlers, transpilers, and a million config files, Jawt gives you a single, unified workflow. You write JML for structure, TypeScript for logic, and Jawt's compiler figures out how to turn it all into an optimised, fast web app.","title":"What's Jawt All About?"},{"location":"#heres-the-gist","text":"One Language for Structure : Use JML to lay out your pages and components. It's clean and easy to read. Component-Based Everything : Build your UI out of reusable components. It's a tried-and-true way to keep things organised. Zero-Config, but Hackable : It works right away with smart defaults, but you can still tweak things if you need to. Instant Feedback : The dev server comes with hot module replacement, so you see your changes live. Optimised by Default : It automatically handles things like code splitting and tree shaking to make sure your app is fast. Full-Fat TypeScript : No compromises. Use all the TypeScript features you know and love.","title":"Here's the Gist:"},{"location":"#how-jml-works","text":"JML is the core of JAWT. Every JML file has a _doctype that tells the compiler what it is. There are two main types: _doctype page home // This is a whole web page. _doctype component Button // This is a reusable building block.","title":"How JML Works"},{"location":"#pages","text":"Pages are the main entry points of your app. They define a full web page with its metadata and structure. _doctype page dashboard import component Layout from \"components/layout\" Page { title: \"Dashboard - My App\" description: \"Application dashboard with analytics\" Layout { section: \"dashboard\" showSidebar: true } }","title":"Pages"},{"location":"#components","text":"Components are the reusable UI bits. You build them once and use them everywhere. _doctype component UserCard Container { style: \"bg-white shadow-md rounded-lg p-6\" Text { content: props.userName style: \"text-xl font-semibold text-gray-800\" } Button { text: \"View Profile\" onClick: () => navigateToProfile(props.userId) style: \"mt-4 bg-blue-500 text-white px-4 py-2 rounded\" } }","title":"Components"},{"location":"#bringing-in-the-logic-with-typescript","text":"Jawt wouldn't be complete without a way to handle dynamic logic. That's where TypeScript comes in. You can write your functions and classes in .ts files and import them right into your JML. // scripts/analytics.ts export function trackPageView(page: string): void { // Analytics logic } export function trackUserAction(action: string, data?: any): void { // User interaction tracking } _doctype component Analytics import script analytics from \"scripts/analytics\" Container { onClick: () => analytics.trackUserAction(\"button_click\", { id: props.buttonId }) }","title":"Bringing in the Logic with TypeScript"},{"location":"#the-workflow","text":"The jawt CLI is your best friend here. It's got everything you need: Start a new project: jawt init my-app Run the dev server: jawt run Build for production: jawt build Debug your app: jawt debug The compiler is smart enough to understand all the different document types and how they depend on each other, spitting out a nice, optimised app at the end.","title":"The Workflow"},{"location":"#the-philosophy","text":"The idea behind Jawt's architecture is to keep things separate and clean: Pages for structure and routing. Components for UI and user interaction. Scripts for business logic and dynamic stuff. This makes your code easier to reason about and helps Jawt optimise how it loads everything.","title":"The Philosophy"},{"location":"#quick-start-example","text":"Here's what a simple Jawt app looks like: my-app/ \u251c\u2500\u2500 app/ \u2502 \u251c\u2500\u2500 index.jml # Home page \u2502 \u2514\u2500\u2500 about/index.jml # About page \u251c\u2500\u2500 components/ \u2502 \u251c\u2500\u2500 layout.jml # Shared layout \u2502 \u2514\u2500\u2500 user-card.jml # Reusable component \u2514\u2500\u2500 scripts/ \u2514\u2500\u2500 analytics.ts # TypeScript functionality Page ( app/index.jml ): _doctype page home import component Layout from \"components/layout\" Page { title: \"Welcome to My App\" Layout { showWelcome: true } } Component ( components/layout.jml ): _doctype component Layout import script analytics from \"scripts/analytics\" Container { style: \"min-h-screen bg-gray-50\" Header { style: \"bg-white shadow-sm p-4\" if (props.showWelcome) { Text { content: \"Welcome!\" style: \"text-2xl font-bold\" } } } onClick: () => analytics.trackPageView(\"home\") } Script ( scripts/analytics.ts ): export function trackPageView(page: string): void { console.log(`Page view: ${page}`) // Analytics implementation }","title":"Quick Start Example"},{"location":"#browser-support","text":"Jawt spits out modern, standards-compliant code that works in all the usual suspects (Chrome, Firefox, Safari, Edge). It'll even add polyfills where needed.","title":"Browser Support"},{"location":"#where-to-next","text":"Ready to dive in?","title":"Where to Next?"},{"location":"#getting-started","text":"Installation & Setup - Get Jawt installed and make your first project. Tutorial - Build a simple app from scratch. Project Structure - Learn how to organise your Jawt projects.","title":"Getting Started"},{"location":"#language-reference","text":"JML Syntax - The full JML language spec. Pages - All about creating pages and routes. Components - Master building interactive components. Scripts - Using TypeScript for dynamic functionality.","title":"Language Reference"},{"location":"#advanced-stuff","text":"Architecture - A peek under the hood. CLI Reference - A guide to all the CLI commands. Configuration - How to customise your build. Deployment - Getting your app out into the world.","title":"Advanced Stuff"},{"location":"#resources","text":"Examples - Sample apps and code patterns. Migration Guide - Coming from another tool? FAQ - Answers to common questions. Contributing - Want to help out?","title":"Resources"},{"location":"api/","text":"","title":"Overview"},{"location":"api/browser/","text":"Jawt Browser API","title":"Browser"},{"location":"api/browser/#jawt-browser-api","text":"","title":"Jawt Browser API"},{"location":"api/state/","text":"Jawt State API","title":"State"},{"location":"api/state/#jawt-state-api","text":"","title":"Jawt State API"},{"location":"architecture/","text":"Jawt \u2013 Just Another Web Tool Jawt is a playful, opinionated, zero-config toolchain for building modern web applications using a custom declarative language called JML. It\u2019s built to scratch the itch of building web UIs in a clear, composable, and developer-controlled way \u2014 with no setup files, no bundler chaos, and no boilerplate jungles . It\u2019s my own curated frontend universe, compiled entirely through Go, designed for real-world usage and personal scalability. \u2728 Philosophy Developer-focused : Jawt is built for a single developer (you) with strong preferences. Declarative-first : You write what you want, Jawt figures out how to do it. Zero-config : Everything just works. You never touch Webpack, TSConfig, or PostCSS again. Highly opinionated : One way (or two at most) to do things. Self-contained : Apps are portable. No .env , node_modules , or configs littering the userland. What Jawt Is A toolchain for building modern Single Page Applications (SPAs). A compiler that transforms .jml declarative files into Web Components written in Lit. A runtime environment with built-in router, state, and system APIs. A library system for reusing logic and UI components across projects. A self-hosted dev server with live reload and full integration. A CLI that handles everything from scaffolding to packaging. What Jawt Is Not Not a general-purpose build tool like Webpack or Vite. Not a framework like React/Vue \u2014 it builds on Web Components via Lit . Not aimed at supporting every use case \u2014 it supports my chosen path. Not exposing internal tooling \u2014 Node, Tailwind, etc. are hidden behind the toolchain. Core Toolchain & Technologies Layer Tool Parser ANTLR Compiler & CLI Go Styling TailwindCSS Logic & Transpilation TypeScript Component Runtime Lit Routing Vaadin Router State Management NanoStores Bundling esbuild (optional) Dev Server + Watcher Custom Go-based live server with HMR Notable Design Constraints No mixing of frameworks \u2014 no React/Vue support. All routing and UI flows are based on Web Components. You own the UX philosophy: consistency is preferred over flexibility. Everything builds down to HTML + JS \u2014 even routing is declarative. Final Thought Jawt is my own full-stack SPA engine , shaped exactly how you want it. It's fast, expressive, local-first, and declarative at the core. It respects the web, uses its standards (TypeScript, Web Components), but gives you a language and system that\u2019s tailored to my creativity \u2014 not the trends.","title":"Overview"},{"location":"architecture/#jawt-just-another-web-tool","text":"Jawt is a playful, opinionated, zero-config toolchain for building modern web applications using a custom declarative language called JML. It\u2019s built to scratch the itch of building web UIs in a clear, composable, and developer-controlled way \u2014 with no setup files, no bundler chaos, and no boilerplate jungles . It\u2019s my own curated frontend universe, compiled entirely through Go, designed for real-world usage and personal scalability.","title":"Jawt \u2013 Just Another Web Tool"},{"location":"architecture/#philosophy","text":"Developer-focused : Jawt is built for a single developer (you) with strong preferences. Declarative-first : You write what you want, Jawt figures out how to do it. Zero-config : Everything just works. You never touch Webpack, TSConfig, or PostCSS again. Highly opinionated : One way (or two at most) to do things. Self-contained : Apps are portable. No .env , node_modules , or configs littering the userland.","title":"\u2728 Philosophy"},{"location":"architecture/#what-jawt-is","text":"A toolchain for building modern Single Page Applications (SPAs). A compiler that transforms .jml declarative files into Web Components written in Lit. A runtime environment with built-in router, state, and system APIs. A library system for reusing logic and UI components across projects. A self-hosted dev server with live reload and full integration. A CLI that handles everything from scaffolding to packaging.","title":"What Jawt Is"},{"location":"architecture/#what-jawt-is-not","text":"Not a general-purpose build tool like Webpack or Vite. Not a framework like React/Vue \u2014 it builds on Web Components via Lit . Not aimed at supporting every use case \u2014 it supports my chosen path. Not exposing internal tooling \u2014 Node, Tailwind, etc. are hidden behind the toolchain.","title":"What Jawt Is Not"},{"location":"architecture/#core-toolchain-technologies","text":"Layer Tool Parser ANTLR Compiler & CLI Go Styling TailwindCSS Logic & Transpilation TypeScript Component Runtime Lit Routing Vaadin Router State Management NanoStores Bundling esbuild (optional) Dev Server + Watcher Custom Go-based live server with HMR","title":"Core Toolchain &amp; Technologies"},{"location":"architecture/#notable-design-constraints","text":"No mixing of frameworks \u2014 no React/Vue support. All routing and UI flows are based on Web Components. You own the UX philosophy: consistency is preferred over flexibility. Everything builds down to HTML + JS \u2014 even routing is declarative.","title":"Notable Design Constraints"},{"location":"architecture/#final-thought","text":"Jawt is my own full-stack SPA engine , shaped exactly how you want it. It's fast, expressive, local-first, and declarative at the core. It respects the web, uses its standards (TypeScript, Web Components), but gives you a language and system that\u2019s tailored to my creativity \u2014 not the trends.","title":"Final Thought"},{"location":"architecture/build-system/","text":"","title":"Build system"},{"location":"architecture/compiler/","text":"","title":"Compiler"},{"location":"architecture/configuration/","text":"","title":"Configuration"},{"location":"architecture/debugger/","text":"","title":"Debugger"},{"location":"architecture/project-types/","text":"Project Types Jawt supports both Applications and Libraries via jawt.config.json . Applications Contain pages ( _doctype page ) Define routing Compiled to self-contained SPAs Use component libraries or logic libraries Libraries Export JML components or TypeScript scripts Can be reused in other Jawt projects via jawt add Defined via jawt.config.json : json { \"type\": \"library\", \"exports\": [\"components/button.jml\", \"scripts/utils.ts\"] }","title":"Project Types"},{"location":"architecture/project-types/#project-types","text":"Jawt supports both Applications and Libraries via jawt.config.json .","title":"Project Types"},{"location":"architecture/project-types/#applications","text":"Contain pages ( _doctype page ) Define routing Compiled to self-contained SPAs Use component libraries or logic libraries","title":"Applications"},{"location":"architecture/project-types/#libraries","text":"Export JML components or TypeScript scripts Can be reused in other Jawt projects via jawt add Defined via jawt.config.json : json { \"type\": \"library\", \"exports\": [\"components/button.jml\", \"scripts/utils.ts\"] }","title":"Libraries"},{"location":"architecture/server/","text":"","title":"Server"},{"location":"architecture/workspace/","text":".jawt/ Workspace Layout The .jawt directory contains everything Jawt needs internally , with no exposure to the user. .jawt/ \u251c\u2500\u2500 config/ # Cached config \u251c\u2500\u2500 libs/ # Installed reusable JML libraries \u251c\u2500\u2500 node/ # Embedded npm modules (logic libraries only) \u251c\u2500\u2500 output/ # Build output (production-ready assets) \u251c\u2500\u2500 generated/ # Compiler-generated files (routes, manifests) \u251c\u2500\u2500 runtime/ # Jawt runtime API: browser.ts, store.ts, etc. \u2514\u2500\u2500 scripts/ # Shared internal helper code","title":"Workspace Layout"},{"location":"architecture/workspace/#jawt-workspace-layout","text":"The .jawt directory contains everything Jawt needs internally , with no exposure to the user. .jawt/ \u251c\u2500\u2500 config/ # Cached config \u251c\u2500\u2500 libs/ # Installed reusable JML libraries \u251c\u2500\u2500 node/ # Embedded npm modules (logic libraries only) \u251c\u2500\u2500 output/ # Build output (production-ready assets) \u251c\u2500\u2500 generated/ # Compiler-generated files (routes, manifests) \u251c\u2500\u2500 runtime/ # Jawt runtime API: browser.ts, store.ts, etc. \u2514\u2500\u2500 scripts/ # Shared internal helper code","title":".jawt/ Workspace Layout"},{"location":"contributing/","text":"Contributing to JAWT","title":"Contributing to JAWT"},{"location":"contributing/#contributing-to-jawt","text":"","title":"Contributing to JAWT"},{"location":"deployment/","text":"","title":"Index"},{"location":"extensibility/","text":"Extensibility Custom Components : Written in JML or Lit + TS Custom Scripts : TypeScript modules importable from JML Logic Libraries : Use jawt install to bring in TypeScript utilities UI Libraries : Create JML component libraries and use via jawt add Prebundled APIs : Extend runtime with my own internal tools","title":"Overview"},{"location":"extensibility/#extensibility","text":"Custom Components : Written in JML or Lit + TS Custom Scripts : TypeScript modules importable from JML Logic Libraries : Use jawt install to bring in TypeScript utilities UI Libraries : Create JML component libraries and use via jawt add Prebundled APIs : Extend runtime with my own internal tools","title":"Extensibility"},{"location":"getting-started/installation/","text":"Getting Set Up Alright, let's get JAWT installed. It's pretty painless. The Quick Way Linux (Debian/Ubuntu) I made a script that handles everything. Just pop this in your terminal: curl -fsSL https://raw.githubusercontent.com/yasufadhili/jawt/main/install.sh | sudo bash This little command will: Figure out your system's architecture. Grab the latest JAWT release. Stick it in the right place. Set up your PATH. Handle all the permissions. Windows (Coming Soon) I'll have an MSI installer for Windows soon. It'll be a simple download-and-click affair. Did it Work? To make sure everything is installed correctly, just ask JAWT for its version: jawt --version You should see something like this: JAWT v0.1.0 Platform: linux/amd64 What You'll Need JAWT is pretty low-maintenance. Supported Systems Linux : x64, ARM64 (Ubuntu 18.04+, CentOS 7+, Debian 9+) macOS : x64, Apple Silicon (macOS 10.15+) Windows : x64, ARM64 (Windows 10+, Windows Server 2019+) Dependencies None. JAWT is a single binary. No need to install anything else. A modern browser (like Firefox, Edge, Chrome, or Safari). Your favourite text editor. If Something Went Wrong Permission Problems (Linux/macOS) If you get permission errors, you probably forgot to run the install script with sudo . curl -fsSL https://raw.githubusercontent.com/yasufadhili/jawt/main/install.sh | sudo bash \"Command Not Found\" If your terminal says jawt: command not found : Linux/macOS : Try restarting your terminal or running: source ~/.bashrc # or ~/.zshrc if you're a zsh person Windows : Restart your Command Prompt or PowerShell. Firewall/Antivirus Warnings Some antivirus programs can be a bit jumpy. JAWT is safe, I promise. You can add an exception for it or, if you're feeling adventurous, build it from the source yourself. The Manual Way If you'd rather do it yourself: Go to the JAWT releases page . Download the right archive for your system. Extract the jawt binary and put it somewhere in your PATH. Make it executable (on Linux/macOS): chmod +x jawt Editor Setup Right now, there's no fancy syntax highlighting or IntelliSense for JML in any major editor. It's on the to-do list! For now, you can just write it as plain text. Configuration JAWT is designed to work without any configuration. But if you want to customise things: Global Config JAWT looks for a config file here: ~/.jawt/config.json (Linux/macOS) %APPDATA%\\jawt\\config.json (Windows) Project Config Each project can have its own jawt.config.json for project-specific settings. Updating JAWT Automatic Updates I've added a command to let JAWT update itself: jawt update Manual Updates Just run the installation script again to get the latest version. Linux/macOS : curl -fsSL https://raw.githubusercontent.com/yasufadhili/jawt/main/install.sh | sudo bash Windows : Download and run the new MSI installer when it's ready. Getting Rid of JAWT Linux/macOS sudo rm /usr/local/bin/jawt sudo rm -rf ~/.jawt Windows Use \"Add or Remove Programs\" or run: jawt uninstall What's Next? Now that you're all set up, you're ready to build something. Create Your First Project - Let's build a simple JAWT app. Project Structure - A look at how JAWT projects are organized. JML Quick Start - The basics of the JML language. CLI Reference - All the commands you can use.","title":"Installation"},{"location":"getting-started/installation/#getting-set-up","text":"Alright, let's get JAWT installed. It's pretty painless.","title":"Getting Set Up"},{"location":"getting-started/installation/#the-quick-way","text":"","title":"The Quick Way"},{"location":"getting-started/installation/#linux-debianubuntu","text":"I made a script that handles everything. Just pop this in your terminal: curl -fsSL https://raw.githubusercontent.com/yasufadhili/jawt/main/install.sh | sudo bash This little command will: Figure out your system's architecture. Grab the latest JAWT release. Stick it in the right place. Set up your PATH. Handle all the permissions.","title":"Linux (Debian/Ubuntu)"},{"location":"getting-started/installation/#windows-coming-soon","text":"I'll have an MSI installer for Windows soon. It'll be a simple download-and-click affair.","title":"Windows (Coming Soon)"},{"location":"getting-started/installation/#did-it-work","text":"To make sure everything is installed correctly, just ask JAWT for its version: jawt --version You should see something like this: JAWT v0.1.0 Platform: linux/amd64","title":"Did it Work?"},{"location":"getting-started/installation/#what-youll-need","text":"JAWT is pretty low-maintenance.","title":"What You'll Need"},{"location":"getting-started/installation/#supported-systems","text":"Linux : x64, ARM64 (Ubuntu 18.04+, CentOS 7+, Debian 9+) macOS : x64, Apple Silicon (macOS 10.15+) Windows : x64, ARM64 (Windows 10+, Windows Server 2019+)","title":"Supported Systems"},{"location":"getting-started/installation/#dependencies","text":"None. JAWT is a single binary. No need to install anything else. A modern browser (like Firefox, Edge, Chrome, or Safari). Your favourite text editor.","title":"Dependencies"},{"location":"getting-started/installation/#if-something-went-wrong","text":"","title":"If Something Went Wrong"},{"location":"getting-started/installation/#permission-problems-linuxmacos","text":"If you get permission errors, you probably forgot to run the install script with sudo . curl -fsSL https://raw.githubusercontent.com/yasufadhili/jawt/main/install.sh | sudo bash","title":"Permission Problems (Linux/macOS)"},{"location":"getting-started/installation/#command-not-found","text":"If your terminal says jawt: command not found : Linux/macOS : Try restarting your terminal or running: source ~/.bashrc # or ~/.zshrc if you're a zsh person Windows : Restart your Command Prompt or PowerShell.","title":"\"Command Not Found\""},{"location":"getting-started/installation/#firewallantivirus-warnings","text":"Some antivirus programs can be a bit jumpy. JAWT is safe, I promise. You can add an exception for it or, if you're feeling adventurous, build it from the source yourself.","title":"Firewall/Antivirus Warnings"},{"location":"getting-started/installation/#the-manual-way","text":"If you'd rather do it yourself: Go to the JAWT releases page . Download the right archive for your system. Extract the jawt binary and put it somewhere in your PATH. Make it executable (on Linux/macOS): chmod +x jawt","title":"The Manual Way"},{"location":"getting-started/installation/#editor-setup","text":"Right now, there's no fancy syntax highlighting or IntelliSense for JML in any major editor. It's on the to-do list! For now, you can just write it as plain text.","title":"Editor Setup"},{"location":"getting-started/installation/#configuration","text":"JAWT is designed to work without any configuration. But if you want to customise things:","title":"Configuration"},{"location":"getting-started/installation/#global-config","text":"JAWT looks for a config file here: ~/.jawt/config.json (Linux/macOS) %APPDATA%\\jawt\\config.json (Windows)","title":"Global Config"},{"location":"getting-started/installation/#project-config","text":"Each project can have its own jawt.config.json for project-specific settings.","title":"Project Config"},{"location":"getting-started/installation/#updating-jawt","text":"","title":"Updating JAWT"},{"location":"getting-started/installation/#automatic-updates","text":"I've added a command to let JAWT update itself: jawt update","title":"Automatic Updates"},{"location":"getting-started/installation/#manual-updates","text":"Just run the installation script again to get the latest version. Linux/macOS : curl -fsSL https://raw.githubusercontent.com/yasufadhili/jawt/main/install.sh | sudo bash Windows : Download and run the new MSI installer when it's ready.","title":"Manual Updates"},{"location":"getting-started/installation/#getting-rid-of-jawt","text":"","title":"Getting Rid of JAWT"},{"location":"getting-started/installation/#linuxmacos","text":"sudo rm /usr/local/bin/jawt sudo rm -rf ~/.jawt","title":"Linux/macOS"},{"location":"getting-started/installation/#windows","text":"Use \"Add or Remove Programs\" or run: jawt uninstall","title":"Windows"},{"location":"getting-started/installation/#whats-next","text":"Now that you're all set up, you're ready to build something. Create Your First Project - Let's build a simple JAWT app. Project Structure - A look at how JAWT projects are organized. JML Quick Start - The basics of the JML language. CLI Reference - All the commands you can use.","title":"What's Next?"},{"location":"getting-started/project-structure/","text":"How a JAWT Project is Laid Out Knowing your way around a JAWT project is key. I've set up a simple, conventional structure so you don't have to waste time making decisions about where to put files. Everything has a place, and once you know the layout, you can get to the fun part: building. The Basic Blueprint When you run jawt init my-project , you get this starting structure: my-project/ \u251c\u2500\u2500 app/ # Your pages and routes \u2502 \u2514\u2500\u2500 index.jml # The main page (the \"/\" route) \u251c\u2500\u2500 components/ # Reusable UI bits and pieces \u251c\u2500\u2500 assets/ # Images, fonts, and other static stuff \u251c\u2500\u2500 app.json # Info about your project \u251c\u2500\u2500 jawt.config.json # Configuration for the build process \u2514\u2500\u2500 dist/ # Where the final, compiled app goes Let's break down what each of these does. The app/ Directory - Your Application's Pages The app/ directory is where the pages of your site live. The structure of this directory defines your app's routes. File-Based Routing JAWT uses the file system to define routes. It's simple and intuitive: app/ \u251c\u2500\u2500 index.jml # \u2192 / (the root page) \u251c\u2500\u2500 about/ \u2502 \u2514\u2500\u2500 index.jml # \u2192 /about \u251c\u2500\u2500 blog/ \u2502 \u251c\u2500\u2500 index.jml # \u2192 /blog \u2502 \u2514\u2500\u2500 [slug].jml # \u2192 /blog/a-cool-post (a dynamic route) \u2514\u2500\u2500 user/ \u251c\u2500\u2500 [id].jml # \u2192 /user/123 (another dynamic route) \u2514\u2500\u2500 [id]/ \u2514\u2500\u2500 settings.jml # \u2192 /user/123/settings Page File Rules Every page file needs to: Be named index.jml for a static route, or use [brackets] for a dynamic one. Start with _doctype page <name> . Have a single Page component as its root element. Example Page # app/about/index.jml _doctype page about import component Layout from \"components/layout\" Page { title: \"About Us\" description: \"Learn more about our company\" Layout { section: \"about\" } } Dynamic Routes Use square brackets for parts of the URL that can change. # app/blog/[slug].jml _doctype page blogPost import component BlogLayout from \"components/blog-layout\" Page { title: \"Blog Post\" description: \"Read our latest blog content\" BlogLayout { slug: params.slug // You can access the dynamic part like this } } The components/ Directory - Reusable Building Blocks Think of components as your own custom HTML tags. You build them once and can reuse them anywhere. The components/ directory is where they all live. Organising Components components/ \u251c\u2500\u2500 layout/ \u2502 \u251c\u2500\u2500 header.jml \u2502 \u251c\u2500\u2500 footer.jml \u2502 \u2514\u2500\u2500 main-layout.jml \u251c\u2500\u2500 ui/ \u2502 \u251c\u2500\u2500 button.jml \u2502 \u251c\u2500\u2500 card.jml \u2502 \u2514\u2500\u2500 modal.jml \u2514\u2500\u2500 forms/ \u251c\u2500\u2500 contact-form.jml \u2514\u2500\u2500 login-form.jml Component File Rules Each component file must: Start with _doctype component <ComponentName> . Export a single component. Use PascalCase for the component name. # components/ui/button.jml _doctype component Button Button { text: props.text || \"Click me\" style: `${props.style || \"\"} px-4 py-2 rounded bg-blue-500 text-white hover:bg-blue-600` onClick: props.onClick } Importing Components You can import components in a few different ways: # Import from the global components directory import component Header from \"components/layout/header\" # Import from the same directory (for page-specific components) import component Card from \"card\" # Import with an alias import component MainButton from \"components/ui/button\" The assets/ Directory - Static Files This is where you put all your non-code files: images, fonts, CSS, etc. Organizing Assets assets/ \u251c\u2500\u2500 images/ \u2502 \u251c\u2500\u2500 logo.svg \u2502 \u251c\u2500\u2500 hero-bg.jpg \u2502 \u2514\u2500\u2500 icons/ \u2502 \u251c\u2500\u2500 home.svg \u2502 \u2514\u2500\u2500 user.svg \u251c\u2500\u2500 fonts/ \u2502 \u251c\u2500\u2500 custom-font.woff2 \u2502 \u2514\u2500\u2500 icons.ttf \u251c\u2500\u2500 styles/ \u2502 \u2514\u2500\u2500 custom.css \u2514\u2500\u2500 data/ \u251c\u2500\u2500 config.json \u2514\u2500\u2500 content.json Using Assets You can reference assets from anywhere in your project. # In a page or component Container { style: \"bg-cover bg-center min-h-screen\" backgroundImage: \"url('/assets/images/hero-bg.jpg')\" Image { src: \"/assets/images/logo.svg\" alt: \"Company Logo\" style: \"w-32 h-32\" } } Configuration Files app.json - Project Info This file holds basic info about your project. { \"name\": \"my-jawt-app\", \"version\": \"1.0.0\", \"description\": \"My awesome JAWT application\", \"author\": \"Your Name\" } jawt.config.json - Build Settings This file controls how JAWT builds and serves your project. { \"build\": { \"outDir\": \"dist\", \"assetsDir\": \"assets\", \"minify\": true }, \"server\": { \"port\": 6500, \"host\": \"localhost\", \"https\": false, \"open\": true }, \"paths\": { \"pages\": \"app\", \"components\": \"components\", \"assets\": \"assets\" } } The dist/ Directory - The Final Product After you run jawt build , this directory will contain your compiled app, ready to be deployed. dist/ \u251c\u2500\u2500 index.html # Compiled root page \u251c\u2500\u2500 about/ \u2502 \u2514\u2500\u2500 index.html # Compiled about page \u251c\u2500\u2500 assets/ \u2502 \u251c\u2500\u2500 js/ \u2502 \u2502 \u251c\u2500\u2500 components.js # Compiled components \u2502 \u2502 \u2514\u2500\u2500 modules.wasm # Compiled modules \u2502 \u251c\u2500\u2500 css/ \u2502 \u2502 \u2514\u2500\u2500 styles.css # Compiled styles \u2502 \u2514\u2500\u2500 images/ \u2502 \u2514\u2500\u2500 ... # Optimised images \u2514\u2500\u2500 manifest.json # A map of the build Best Practices 1. Group by Feature Organise your components by what they do, not what they are. components/ \u251c\u2500\u2500 auth/ # Auth-related components \u2502 \u251c\u2500\u2500 login-form.jml \u2502 \u2514\u2500\u2500 signup-form.jml \u251c\u2500\u2500 dashboard/ # Dashboard-specific components \u2502 \u251c\u2500\u2500 stats-card.jml \u2502 \u2514\u2500\u2500 chart.jml \u2514\u2500\u2500 common/ # Shared components used everywhere \u251c\u2500\u2500 button.jml \u2514\u2500\u2500 modal.jml 2. Name Things Clearly Use descriptive names for your files. # Good components/user/profile-card.jml components/navigation/main-menu.jml # Not so good components/card.jml components/menu.jml 3. Don't Go Too Deep Try to keep your directory structure relatively flat (3-4 levels max). # Good components/forms/contact/contact-form.jml # A bit much components/ui/forms/contact/complex/contact-form.jml The Workflow Starting Out # Go to your project directory cd my-project # Start the dev server jawt run # In another terminal, you can run the debugger (optional) jawt debug Building for Production # Create an optimized build jawt build # Serve the production build locally to test it jawt serve Common Questions Import Not Working? Problem : Component not found. Solution : Double-check your import paths. Make sure they're relative to the correct directory. # Correct import component Button from \"components/ui/button\" # Incorrect (usually) import component Button from \"ui/button\" Page Not Showing Up? Problem : A page isn't accessible at its URL. Solution : Check the file name and directory structure in app/ . # For the /about route, this is correct: app/about/index.jml # This is wrong: app/about.jml What's Next? Now that you know how a JAWT project is structured, you can: Organise your own projects with this structure in mind. Plan out new projects before you start coding. Create your own project templates for different types of apps. That's it! You're ready to start building well-organised, scalable apps with JAWT.","title":"Project Structure"},{"location":"getting-started/project-structure/#how-a-jawt-project-is-laid-out","text":"Knowing your way around a JAWT project is key. I've set up a simple, conventional structure so you don't have to waste time making decisions about where to put files. Everything has a place, and once you know the layout, you can get to the fun part: building.","title":"How a JAWT Project is Laid Out"},{"location":"getting-started/project-structure/#the-basic-blueprint","text":"When you run jawt init my-project , you get this starting structure: my-project/ \u251c\u2500\u2500 app/ # Your pages and routes \u2502 \u2514\u2500\u2500 index.jml # The main page (the \"/\" route) \u251c\u2500\u2500 components/ # Reusable UI bits and pieces \u251c\u2500\u2500 assets/ # Images, fonts, and other static stuff \u251c\u2500\u2500 app.json # Info about your project \u251c\u2500\u2500 jawt.config.json # Configuration for the build process \u2514\u2500\u2500 dist/ # Where the final, compiled app goes Let's break down what each of these does.","title":"The Basic Blueprint"},{"location":"getting-started/project-structure/#the-app-directory-your-applications-pages","text":"The app/ directory is where the pages of your site live. The structure of this directory defines your app's routes.","title":"The app/ Directory - Your Application's Pages"},{"location":"getting-started/project-structure/#file-based-routing","text":"JAWT uses the file system to define routes. It's simple and intuitive: app/ \u251c\u2500\u2500 index.jml # \u2192 / (the root page) \u251c\u2500\u2500 about/ \u2502 \u2514\u2500\u2500 index.jml # \u2192 /about \u251c\u2500\u2500 blog/ \u2502 \u251c\u2500\u2500 index.jml # \u2192 /blog \u2502 \u2514\u2500\u2500 [slug].jml # \u2192 /blog/a-cool-post (a dynamic route) \u2514\u2500\u2500 user/ \u251c\u2500\u2500 [id].jml # \u2192 /user/123 (another dynamic route) \u2514\u2500\u2500 [id]/ \u2514\u2500\u2500 settings.jml # \u2192 /user/123/settings","title":"File-Based Routing"},{"location":"getting-started/project-structure/#page-file-rules","text":"Every page file needs to: Be named index.jml for a static route, or use [brackets] for a dynamic one. Start with _doctype page <name> . Have a single Page component as its root element.","title":"Page File Rules"},{"location":"getting-started/project-structure/#example-page","text":"# app/about/index.jml _doctype page about import component Layout from \"components/layout\" Page { title: \"About Us\" description: \"Learn more about our company\" Layout { section: \"about\" } }","title":"Example Page"},{"location":"getting-started/project-structure/#dynamic-routes","text":"Use square brackets for parts of the URL that can change. # app/blog/[slug].jml _doctype page blogPost import component BlogLayout from \"components/blog-layout\" Page { title: \"Blog Post\" description: \"Read our latest blog content\" BlogLayout { slug: params.slug // You can access the dynamic part like this } }","title":"Dynamic Routes"},{"location":"getting-started/project-structure/#the-components-directory-reusable-building-blocks","text":"Think of components as your own custom HTML tags. You build them once and can reuse them anywhere. The components/ directory is where they all live.","title":"The components/ Directory - Reusable Building Blocks"},{"location":"getting-started/project-structure/#organising-components","text":"components/ \u251c\u2500\u2500 layout/ \u2502 \u251c\u2500\u2500 header.jml \u2502 \u251c\u2500\u2500 footer.jml \u2502 \u2514\u2500\u2500 main-layout.jml \u251c\u2500\u2500 ui/ \u2502 \u251c\u2500\u2500 button.jml \u2502 \u251c\u2500\u2500 card.jml \u2502 \u2514\u2500\u2500 modal.jml \u2514\u2500\u2500 forms/ \u251c\u2500\u2500 contact-form.jml \u2514\u2500\u2500 login-form.jml","title":"Organising Components"},{"location":"getting-started/project-structure/#component-file-rules","text":"Each component file must: Start with _doctype component <ComponentName> . Export a single component. Use PascalCase for the component name. # components/ui/button.jml _doctype component Button Button { text: props.text || \"Click me\" style: `${props.style || \"\"} px-4 py-2 rounded bg-blue-500 text-white hover:bg-blue-600` onClick: props.onClick }","title":"Component File Rules"},{"location":"getting-started/project-structure/#importing-components","text":"You can import components in a few different ways: # Import from the global components directory import component Header from \"components/layout/header\" # Import from the same directory (for page-specific components) import component Card from \"card\" # Import with an alias import component MainButton from \"components/ui/button\"","title":"Importing Components"},{"location":"getting-started/project-structure/#the-assets-directory-static-files","text":"This is where you put all your non-code files: images, fonts, CSS, etc.","title":"The assets/ Directory - Static Files"},{"location":"getting-started/project-structure/#organizing-assets","text":"assets/ \u251c\u2500\u2500 images/ \u2502 \u251c\u2500\u2500 logo.svg \u2502 \u251c\u2500\u2500 hero-bg.jpg \u2502 \u2514\u2500\u2500 icons/ \u2502 \u251c\u2500\u2500 home.svg \u2502 \u2514\u2500\u2500 user.svg \u251c\u2500\u2500 fonts/ \u2502 \u251c\u2500\u2500 custom-font.woff2 \u2502 \u2514\u2500\u2500 icons.ttf \u251c\u2500\u2500 styles/ \u2502 \u2514\u2500\u2500 custom.css \u2514\u2500\u2500 data/ \u251c\u2500\u2500 config.json \u2514\u2500\u2500 content.json","title":"Organizing Assets"},{"location":"getting-started/project-structure/#using-assets","text":"You can reference assets from anywhere in your project. # In a page or component Container { style: \"bg-cover bg-center min-h-screen\" backgroundImage: \"url('/assets/images/hero-bg.jpg')\" Image { src: \"/assets/images/logo.svg\" alt: \"Company Logo\" style: \"w-32 h-32\" } }","title":"Using Assets"},{"location":"getting-started/project-structure/#configuration-files","text":"","title":"Configuration Files"},{"location":"getting-started/project-structure/#appjson-project-info","text":"This file holds basic info about your project. { \"name\": \"my-jawt-app\", \"version\": \"1.0.0\", \"description\": \"My awesome JAWT application\", \"author\": \"Your Name\" }","title":"app.json - Project Info"},{"location":"getting-started/project-structure/#jawtconfigjson-build-settings","text":"This file controls how JAWT builds and serves your project. { \"build\": { \"outDir\": \"dist\", \"assetsDir\": \"assets\", \"minify\": true }, \"server\": { \"port\": 6500, \"host\": \"localhost\", \"https\": false, \"open\": true }, \"paths\": { \"pages\": \"app\", \"components\": \"components\", \"assets\": \"assets\" } }","title":"jawt.config.json - Build Settings"},{"location":"getting-started/project-structure/#the-dist-directory-the-final-product","text":"After you run jawt build , this directory will contain your compiled app, ready to be deployed. dist/ \u251c\u2500\u2500 index.html # Compiled root page \u251c\u2500\u2500 about/ \u2502 \u2514\u2500\u2500 index.html # Compiled about page \u251c\u2500\u2500 assets/ \u2502 \u251c\u2500\u2500 js/ \u2502 \u2502 \u251c\u2500\u2500 components.js # Compiled components \u2502 \u2502 \u2514\u2500\u2500 modules.wasm # Compiled modules \u2502 \u251c\u2500\u2500 css/ \u2502 \u2502 \u2514\u2500\u2500 styles.css # Compiled styles \u2502 \u2514\u2500\u2500 images/ \u2502 \u2514\u2500\u2500 ... # Optimised images \u2514\u2500\u2500 manifest.json # A map of the build","title":"The dist/ Directory - The Final Product"},{"location":"getting-started/project-structure/#best-practices","text":"","title":"Best Practices"},{"location":"getting-started/project-structure/#1-group-by-feature","text":"Organise your components by what they do, not what they are. components/ \u251c\u2500\u2500 auth/ # Auth-related components \u2502 \u251c\u2500\u2500 login-form.jml \u2502 \u2514\u2500\u2500 signup-form.jml \u251c\u2500\u2500 dashboard/ # Dashboard-specific components \u2502 \u251c\u2500\u2500 stats-card.jml \u2502 \u2514\u2500\u2500 chart.jml \u2514\u2500\u2500 common/ # Shared components used everywhere \u251c\u2500\u2500 button.jml \u2514\u2500\u2500 modal.jml","title":"1. Group by Feature"},{"location":"getting-started/project-structure/#2-name-things-clearly","text":"Use descriptive names for your files. # Good components/user/profile-card.jml components/navigation/main-menu.jml # Not so good components/card.jml components/menu.jml","title":"2. Name Things Clearly"},{"location":"getting-started/project-structure/#3-dont-go-too-deep","text":"Try to keep your directory structure relatively flat (3-4 levels max). # Good components/forms/contact/contact-form.jml # A bit much components/ui/forms/contact/complex/contact-form.jml","title":"3. Don't Go Too Deep"},{"location":"getting-started/project-structure/#the-workflow","text":"","title":"The Workflow"},{"location":"getting-started/project-structure/#starting-out","text":"# Go to your project directory cd my-project # Start the dev server jawt run # In another terminal, you can run the debugger (optional) jawt debug","title":"Starting Out"},{"location":"getting-started/project-structure/#building-for-production","text":"# Create an optimized build jawt build # Serve the production build locally to test it jawt serve","title":"Building for Production"},{"location":"getting-started/project-structure/#common-questions","text":"","title":"Common Questions"},{"location":"getting-started/project-structure/#import-not-working","text":"Problem : Component not found. Solution : Double-check your import paths. Make sure they're relative to the correct directory. # Correct import component Button from \"components/ui/button\" # Incorrect (usually) import component Button from \"ui/button\"","title":"Import Not Working?"},{"location":"getting-started/project-structure/#page-not-showing-up","text":"Problem : A page isn't accessible at its URL. Solution : Check the file name and directory structure in app/ . # For the /about route, this is correct: app/about/index.jml # This is wrong: app/about.jml","title":"Page Not Showing Up?"},{"location":"getting-started/project-structure/#whats-next","text":"Now that you know how a JAWT project is structured, you can: Organise your own projects with this structure in mind. Plan out new projects before you start coding. Create your own project templates for different types of apps. That's it! You're ready to start building well-organised, scalable apps with JAWT.","title":"What's Next?"},{"location":"getting-started/routing/","text":"","title":"Routing"},{"location":"jml/","text":"JML: The Language of JAWT JML is the language you'll be speaking when you build with JAWT. I designed it to be a declarative language that gets out of your way, mixing the structural clarity of markup with the power of TypeScript. What's the Big Deal with JML? Think of JML as a way to write blueprints for your app. Instead of telling the browser how to draw everything step-by-step, you just describe what you want the final thing to look like. JML Supports: Declarative UI trees Embedded TypeScript logic Page and component document types Imports for components, scripts, runtime APIs, and stores For-loops and expressions Type-checked props The Two Flavours of JML JML has two main \"document types,\" each with a specific job: Pages \u2014 The main canvases for your application. Components \u2014 The reusable Lego bricks you build with. This separation keeps things clean. Pages handle the overall structure and routing, while components handle the interactive bits and pieces. The Philosophy: Declarative First JML is all about being declarative. You describe the end result, not the process. // You describe WHAT you want Card { title: \"Welcome\" style: \"bg-white shadow-lg rounded-lg p-6\" Text { content: \"Hello, world!\" style: \"text-gray-700\" } } This is a lot cleaner than manually creating DOM elements, setting attributes, and appending them to each other. Familiar Syntax If you've used TypeScript, JML should feel pretty familiar. I borrowed a lot of its syntax for variables, functions, and types. // Variables and functions feel like TypeScript const greeting = \"Hello, JAWT!\" function handleClick(): void { console.log(\"Button clicked!\") } // But the UI part is declarative Button { text: greeting onClick: handleClick style: \"bg-blue-500 text-white px-4 py-2 rounded\" } The Document Types in Detail Pages: Your App's Entry Points A page represents a whole web page. It's where you define things like the page title and pull in the components that make up the UI. _doctype page home import component Layout from \"components/layout\" Page { title: \"Welcome to My App\" description: \"A minimal web application built with JAWT\" Layout { content: \"Hello, world!\" } } Key things to remember: Always starts with _doctype page . Can only have one component directly inside the Page block. Handles routing and page-level metadata. Components: Your Reusable Building Blocks Components are the best part. They're like custom HTML tags you can reuse everywhere. They can have their own logic and can be composed to create really complex UIs. _doctype component UserCard Card { style: \"border rounded-lg p-4 shadow\" Avatar { src: props.avatarUrl alt: props.name style: \"w-12 h-12 rounded-full\" } Text { content: props.name style: \"font-semibold text-lg\" } Text { content: props.email style: \"text-gray-600\" } } Key things to remember: Starts with _doctype component . Uses props to get data from its parent. Can import other components and scripts. The Import System JML lets you pull in components and TypeScript code easily. // Import components from the global components directory import component Button from \"components/button\" import component Card from \"components/card\" // Import from the same directory (page-specific components) import component LocalWidget from \"widget\" // Import TypeScript scripts for dynamic functionality import script analytics from \"scripts/analytics\" import script utils from \"scripts/utils\" // Import browser APIs (components only) import browser TypeScript Integration This is where JML really shines. You can write complex logic in TypeScript and use it right inside your components. // scripts/counter.ts export class Counter { private count: number = 0 increment(): number { return ++this.count } decrement(): number { return --this.count } getValue(): number { return this.count } } export function formatCount(count: number): string { return `Count: ${count}` } _doctype component CounterWidget import script counter from \"scripts/counter\" Container { style: \"flex items-center space-x-4\" Button { text: \"-\" onClick: () => handleDecrement() style: \"bg-red-500 text-white px-3 py-1 rounded\" } Text { content: counter.formatCount(currentCount) style: \"font-mono text-lg\" } Button { text: \"+\" onClick: () => handleIncrement() style: \"bg-green-500 text-white px-3 py-1 rounded\" } } const counterInstance = new counter.Counter() let currentCount = 0 function handleIncrement(): void { currentCount = counterInstance.increment() } function handleDecrement(): void { currentCount = counterInstance.decrement() } Styling with Tailwind CSS JML is set up to work with Tailwind CSS out of the box. Just use the style property. Container { style: \"max-w-4xl mx-auto px-4 py-8\" Header { style: \"text-3xl font-bold text-gray-900 mb-6\" content: \"My Application\" } Grid { style: \"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\" // Grid items... } } Making Things Interactive Adding interactivity feels natural in JML. _doctype component TodoList import script todoManager from \"scripts/todo-manager\" Container { style: \"max-w-md mx-auto\" Input { placeholder: \"Add a new task...\" onEnter: (value) => addTodo(value) style: \"w-full p-2 border rounded mb-4\" } List { style: \"space-y-2\" for (todo in todos) { TodoItem { text: todo.text completed: todo.completed onToggle: () => toggleTodo(todo.id) onDelete: () => deleteTodo(todo.id) } } } } let todos = [] function addTodo(text: string): void { todos = todoManager.addTodo(todos, text) } function toggleTodo(id: string): void { todos = todoManager.toggleTodo(todos, id) } function deleteTodo(id: string): void { todos = todoManager.deleteTodo(todos, id) } The Developer Experience Hot Module Replacement When you save a JML file, the changes show up in your browser instantly. It makes for a really smooth workflow. Type Safety JML uses TypeScript's type system, so you get type checking for free. // TypeScript-style type annotations function processUser(user: { name: string; age: number }): string { return `${user.name} is ${user.age} years old` } // Props are type-checked automatically UserCard { name: \"John Doe\" // \u2705 Correct type age: \"thirty\" // \u274c Type error: expected number } Composition is Key JML is all about building big things from small, simple pieces. _doctype component BlogPost Article { style: \"max-w-2xl mx-auto\" PostHeader { title: props.title author: props.author publishDate: props.date } PostContent { content: props.content style: \"prose prose-lg\" } PostFooter { tags: props.tags shareUrl: props.url } } How to Organise Your Project A typical JAWT project has a structure that makes sense with the language's design: my-jawt-app/ \u251c\u2500\u2500 app/ # Pages (routes) \u2502 \u251c\u2500\u2500 index.jml # Home page \u2502 \u251c\u2500\u2500 about/ \u2502 \u2502 \u2514\u2500\u2500 index.jml # About page \u2502 \u2514\u2500\u2500 blog/ \u2502 \u251c\u2500\u2500 index.jml # Blog listing \u2502 \u2514\u2500\u2500 [slug].jml # Individual blog posts \u251c\u2500\u2500 components/ # Reusable components \u2502 \u251c\u2500\u2500 layout.jml \u2502 \u251c\u2500\u2500 button.jml \u2502 \u2514\u2500\u2500 card.jml \u251c\u2500\u2500 scripts/ # TypeScript functionality \u2502 \u251c\u2500\u2500 analytics.ts \u2502 \u251c\u2500\u2500 utils.ts \u2502 \u2514\u2500\u2500 api.ts \u2514\u2500\u2500 jawt.config.json # Configuration Why Bother? A Unified Experience With JML, you don't have to constantly switch between HTML, CSS, and JavaScript files and mindsets. It's one cohesive way to build your app. Optimised for You Jawt's compiler is smart about how it builds your code. Pages become lean HTML, components become efficient Web Components, and your TypeScript just works. Code That's Easy to Read Because it's declarative, JML code often reads like a description of the UI, which makes it easier to come back to later. Getting Your Hands Dirty The best way to learn is by doing. Start with a simple page and build from there. _doctype page welcome Page { title: \"Welcome to JAWT\" Container { style: \"min-h-screen flex items-center justify-center bg-gray-100\" Card { style: \"bg-white p-8 rounded-lg shadow-lg text-center\" Text { content: \"Hello, JAWT!\" style: \"text-2xl font-bold text-gray-900 mb-4\" } Text { content: \"Your first JML application is running.\" style: \"text-gray-600\" } } } } What's Next? Now that you've got the basics of JML, you can dive deeper: Pages \u2014 Learn about routing and page structure. Components \u2014 Master props, state, and all things component. Scripts \u2014 Get the full scoop on TypeScript integration.","title":"Overview"},{"location":"jml/#jml-the-language-of-jawt","text":"JML is the language you'll be speaking when you build with JAWT. I designed it to be a declarative language that gets out of your way, mixing the structural clarity of markup with the power of TypeScript.","title":"JML: The Language of JAWT"},{"location":"jml/#whats-the-big-deal-with-jml","text":"Think of JML as a way to write blueprints for your app. Instead of telling the browser how to draw everything step-by-step, you just describe what you want the final thing to look like.","title":"What's the Big Deal with JML?"},{"location":"jml/#jml-supports","text":"Declarative UI trees Embedded TypeScript logic Page and component document types Imports for components, scripts, runtime APIs, and stores For-loops and expressions Type-checked props","title":"JML Supports:"},{"location":"jml/#the-two-flavours-of-jml","text":"JML has two main \"document types,\" each with a specific job: Pages \u2014 The main canvases for your application. Components \u2014 The reusable Lego bricks you build with. This separation keeps things clean. Pages handle the overall structure and routing, while components handle the interactive bits and pieces.","title":"The Two Flavours of JML"},{"location":"jml/#the-philosophy-declarative-first","text":"JML is all about being declarative. You describe the end result, not the process. // You describe WHAT you want Card { title: \"Welcome\" style: \"bg-white shadow-lg rounded-lg p-6\" Text { content: \"Hello, world!\" style: \"text-gray-700\" } } This is a lot cleaner than manually creating DOM elements, setting attributes, and appending them to each other.","title":"The Philosophy: Declarative First"},{"location":"jml/#familiar-syntax","text":"If you've used TypeScript, JML should feel pretty familiar. I borrowed a lot of its syntax for variables, functions, and types. // Variables and functions feel like TypeScript const greeting = \"Hello, JAWT!\" function handleClick(): void { console.log(\"Button clicked!\") } // But the UI part is declarative Button { text: greeting onClick: handleClick style: \"bg-blue-500 text-white px-4 py-2 rounded\" }","title":"Familiar Syntax"},{"location":"jml/#the-document-types-in-detail","text":"","title":"The Document Types in Detail"},{"location":"jml/#pages-your-apps-entry-points","text":"A page represents a whole web page. It's where you define things like the page title and pull in the components that make up the UI. _doctype page home import component Layout from \"components/layout\" Page { title: \"Welcome to My App\" description: \"A minimal web application built with JAWT\" Layout { content: \"Hello, world!\" } } Key things to remember: Always starts with _doctype page . Can only have one component directly inside the Page block. Handles routing and page-level metadata.","title":"Pages: Your App's Entry Points"},{"location":"jml/#components-your-reusable-building-blocks","text":"Components are the best part. They're like custom HTML tags you can reuse everywhere. They can have their own logic and can be composed to create really complex UIs. _doctype component UserCard Card { style: \"border rounded-lg p-4 shadow\" Avatar { src: props.avatarUrl alt: props.name style: \"w-12 h-12 rounded-full\" } Text { content: props.name style: \"font-semibold text-lg\" } Text { content: props.email style: \"text-gray-600\" } } Key things to remember: Starts with _doctype component . Uses props to get data from its parent. Can import other components and scripts.","title":"Components: Your Reusable Building Blocks"},{"location":"jml/#the-import-system","text":"JML lets you pull in components and TypeScript code easily. // Import components from the global components directory import component Button from \"components/button\" import component Card from \"components/card\" // Import from the same directory (page-specific components) import component LocalWidget from \"widget\" // Import TypeScript scripts for dynamic functionality import script analytics from \"scripts/analytics\" import script utils from \"scripts/utils\" // Import browser APIs (components only) import browser","title":"The Import System"},{"location":"jml/#typescript-integration","text":"This is where JML really shines. You can write complex logic in TypeScript and use it right inside your components. // scripts/counter.ts export class Counter { private count: number = 0 increment(): number { return ++this.count } decrement(): number { return --this.count } getValue(): number { return this.count } } export function formatCount(count: number): string { return `Count: ${count}` } _doctype component CounterWidget import script counter from \"scripts/counter\" Container { style: \"flex items-center space-x-4\" Button { text: \"-\" onClick: () => handleDecrement() style: \"bg-red-500 text-white px-3 py-1 rounded\" } Text { content: counter.formatCount(currentCount) style: \"font-mono text-lg\" } Button { text: \"+\" onClick: () => handleIncrement() style: \"bg-green-500 text-white px-3 py-1 rounded\" } } const counterInstance = new counter.Counter() let currentCount = 0 function handleIncrement(): void { currentCount = counterInstance.increment() } function handleDecrement(): void { currentCount = counterInstance.decrement() }","title":"TypeScript Integration"},{"location":"jml/#styling-with-tailwind-css","text":"JML is set up to work with Tailwind CSS out of the box. Just use the style property. Container { style: \"max-w-4xl mx-auto px-4 py-8\" Header { style: \"text-3xl font-bold text-gray-900 mb-6\" content: \"My Application\" } Grid { style: \"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\" // Grid items... } }","title":"Styling with Tailwind CSS"},{"location":"jml/#making-things-interactive","text":"Adding interactivity feels natural in JML. _doctype component TodoList import script todoManager from \"scripts/todo-manager\" Container { style: \"max-w-md mx-auto\" Input { placeholder: \"Add a new task...\" onEnter: (value) => addTodo(value) style: \"w-full p-2 border rounded mb-4\" } List { style: \"space-y-2\" for (todo in todos) { TodoItem { text: todo.text completed: todo.completed onToggle: () => toggleTodo(todo.id) onDelete: () => deleteTodo(todo.id) } } } } let todos = [] function addTodo(text: string): void { todos = todoManager.addTodo(todos, text) } function toggleTodo(id: string): void { todos = todoManager.toggleTodo(todos, id) } function deleteTodo(id: string): void { todos = todoManager.deleteTodo(todos, id) }","title":"Making Things Interactive"},{"location":"jml/#the-developer-experience","text":"","title":"The Developer Experience"},{"location":"jml/#hot-module-replacement","text":"When you save a JML file, the changes show up in your browser instantly. It makes for a really smooth workflow.","title":"Hot Module Replacement"},{"location":"jml/#type-safety","text":"JML uses TypeScript's type system, so you get type checking for free. // TypeScript-style type annotations function processUser(user: { name: string; age: number }): string { return `${user.name} is ${user.age} years old` } // Props are type-checked automatically UserCard { name: \"John Doe\" // \u2705 Correct type age: \"thirty\" // \u274c Type error: expected number }","title":"Type Safety"},{"location":"jml/#composition-is-key","text":"JML is all about building big things from small, simple pieces. _doctype component BlogPost Article { style: \"max-w-2xl mx-auto\" PostHeader { title: props.title author: props.author publishDate: props.date } PostContent { content: props.content style: \"prose prose-lg\" } PostFooter { tags: props.tags shareUrl: props.url } }","title":"Composition is Key"},{"location":"jml/#how-to-organise-your-project","text":"A typical JAWT project has a structure that makes sense with the language's design: my-jawt-app/ \u251c\u2500\u2500 app/ # Pages (routes) \u2502 \u251c\u2500\u2500 index.jml # Home page \u2502 \u251c\u2500\u2500 about/ \u2502 \u2502 \u2514\u2500\u2500 index.jml # About page \u2502 \u2514\u2500\u2500 blog/ \u2502 \u251c\u2500\u2500 index.jml # Blog listing \u2502 \u2514\u2500\u2500 [slug].jml # Individual blog posts \u251c\u2500\u2500 components/ # Reusable components \u2502 \u251c\u2500\u2500 layout.jml \u2502 \u251c\u2500\u2500 button.jml \u2502 \u2514\u2500\u2500 card.jml \u251c\u2500\u2500 scripts/ # TypeScript functionality \u2502 \u251c\u2500\u2500 analytics.ts \u2502 \u251c\u2500\u2500 utils.ts \u2502 \u2514\u2500\u2500 api.ts \u2514\u2500\u2500 jawt.config.json # Configuration","title":"How to Organise Your Project"},{"location":"jml/#why-bother","text":"","title":"Why Bother?"},{"location":"jml/#a-unified-experience","text":"With JML, you don't have to constantly switch between HTML, CSS, and JavaScript files and mindsets. It's one cohesive way to build your app.","title":"A Unified Experience"},{"location":"jml/#optimised-for-you","text":"Jawt's compiler is smart about how it builds your code. Pages become lean HTML, components become efficient Web Components, and your TypeScript just works.","title":"Optimised for You"},{"location":"jml/#code-thats-easy-to-read","text":"Because it's declarative, JML code often reads like a description of the UI, which makes it easier to come back to later.","title":"Code That's Easy to Read"},{"location":"jml/#getting-your-hands-dirty","text":"The best way to learn is by doing. Start with a simple page and build from there. _doctype page welcome Page { title: \"Welcome to JAWT\" Container { style: \"min-h-screen flex items-center justify-center bg-gray-100\" Card { style: \"bg-white p-8 rounded-lg shadow-lg text-center\" Text { content: \"Hello, JAWT!\" style: \"text-2xl font-bold text-gray-900 mb-4\" } Text { content: \"Your first JML application is running.\" style: \"text-gray-600\" } } } }","title":"Getting Your Hands Dirty"},{"location":"jml/#whats-next","text":"Now that you've got the basics of JML, you can dive deeper: Pages \u2014 Learn about routing and page structure. Components \u2014 Master props, state, and all things component. Scripts \u2014 Get the full scoop on TypeScript integration.","title":"What's Next?"},{"location":"jml/components/","text":"","title":"Components"},{"location":"jml/modules/","text":"","title":"Modules"},{"location":"jml/pages/","text":"","title":"Pages"},{"location":"jml/scripting/","text":"Jml Scripting","title":"Scripting"},{"location":"jml/scripting/#jml-scripting","text":"","title":"Jml Scripting"},{"location":"jml/syntax/","text":"","title":"Syntax"},{"location":"misc/bible/","text":"\ud83d\udcd6 The Book of JML \u2014 The Unofficial Jawt Bible \"In the beginning, there was HTML. Then chaos. Then JSX. And then, from the void, rose JML.\" \u2728 Chapter 1: The Origin of Structure \"And the developer said, let there be less noise. And JML appeared, pure and declarative.\" You shall write no <div> . You shall not repeat thyself with boilerplate. The _doctype shall declare the purpose of every JML file. All things must begin with structure, for structure is clarity. _doctype page home Page { title: \"Welcome\" Container { Text { content: \"And it was good.\" } } } \ud83d\udd25 Chapter 2: The Rules of Declaration \"Thou shalt describe thy UI, not assemble it.\" Components are sacred. Props are passed, not injected. Logic resides in script. Structure lives in clarity. _doctype component HelloButton import script actions from \"scripts/actions\" Button { text: \"Say Hello\" onClick: () => actions.sayHello() } \ud83e\uddf1 Chapter 3: The Temple of Components \"Let thy UI be built from blocks, like holy Lego bricks of type safety and composability.\" Reuse is divine. Every component must start with _doctype component . Props must be respected as the interface of the sacred. _doctype component UserCard Card { Text { content: props.username } Text { content: props.email } } \ud83d\udd00 Chapter 4: The Path of Routing \"Ye shall not manually configure thy routes. The compiler knows thy ways.\" Routing shall be derived. Paths become components. Components become paths. Let there be no router.js , only pages. _doctype page about Page { title: \"About Us\" Container { Text { content: \"We exist because JSX is pain.\" } } } \ud83e\udde0 Chapter 5: The Wisdom of Store \"You needed localStorage. Now it is store.set() .\" The store is simple. The store remembers. The store observes. import store Input { onEnter: (value) => store.set(\"username\", value) } Text { content: store.get(\"username\") } \u2699\ufe0f Chapter 6: The Rites of Runtime \"The browser API shall be unified under one name: browser \" You shall scroll with browser.scrollToTop() You shall update the title with browser.setTitle() You shall query not with document.querySelector , but with browser.query() \ud83d\udce6 Chapter 7: The Scroll of Reuse \"Thou shalt not copy-paste thy components across projects. Thou shalt jawt add .\" Share JML components through libraries. Use jawt build --as-lib to sanctify them. Let others use them \u2014 if you dare. \ud83d\ude45 Chapter 8: The Warnings of Temptation \"Thou may be tempted to eject the toolchain, to override it, to reach for React.\" You shall not question the compiler. You shall not eject. You shall not say \u201cBut in Vue, I could just\u2014\u201d. JML is law. Jawt is order. JSX is noise. \ud83e\uddd9\u200d\u2642\ufe0f Final Words: The Path of One \"Jawt was never meant to be for everyone. It was forged in solitude, to suit the needs of the one.\" But if you walk the path, if you accept the rules, and if you embrace the declarative truth \u2014 you may never write <div class=\"container\"> again. And that, dear pilgrim, is freedom.","title":"\ud83d\udcd6 The Book of JML \u2014 The Unofficial Jawt Bible"},{"location":"misc/bible/#the-book-of-jml-the-unofficial-jawt-bible","text":"\"In the beginning, there was HTML. Then chaos. Then JSX. And then, from the void, rose JML.\"","title":"\ud83d\udcd6 The Book of JML \u2014 The Unofficial Jawt Bible"},{"location":"misc/bible/#chapter-1-the-origin-of-structure","text":"\"And the developer said, let there be less noise. And JML appeared, pure and declarative.\" You shall write no <div> . You shall not repeat thyself with boilerplate. The _doctype shall declare the purpose of every JML file. All things must begin with structure, for structure is clarity. _doctype page home Page { title: \"Welcome\" Container { Text { content: \"And it was good.\" } } }","title":"\u2728 Chapter 1: The Origin of Structure"},{"location":"misc/bible/#chapter-2-the-rules-of-declaration","text":"\"Thou shalt describe thy UI, not assemble it.\" Components are sacred. Props are passed, not injected. Logic resides in script. Structure lives in clarity. _doctype component HelloButton import script actions from \"scripts/actions\" Button { text: \"Say Hello\" onClick: () => actions.sayHello() }","title":"\ud83d\udd25 Chapter 2: The Rules of Declaration"},{"location":"misc/bible/#chapter-3-the-temple-of-components","text":"\"Let thy UI be built from blocks, like holy Lego bricks of type safety and composability.\" Reuse is divine. Every component must start with _doctype component . Props must be respected as the interface of the sacred. _doctype component UserCard Card { Text { content: props.username } Text { content: props.email } }","title":"\ud83e\uddf1 Chapter 3: The Temple of Components"},{"location":"misc/bible/#chapter-4-the-path-of-routing","text":"\"Ye shall not manually configure thy routes. The compiler knows thy ways.\" Routing shall be derived. Paths become components. Components become paths. Let there be no router.js , only pages. _doctype page about Page { title: \"About Us\" Container { Text { content: \"We exist because JSX is pain.\" } } }","title":"\ud83d\udd00 Chapter 4: The Path of Routing"},{"location":"misc/bible/#chapter-5-the-wisdom-of-store","text":"\"You needed localStorage. Now it is store.set() .\" The store is simple. The store remembers. The store observes. import store Input { onEnter: (value) => store.set(\"username\", value) } Text { content: store.get(\"username\") }","title":"\ud83e\udde0 Chapter 5: The Wisdom of Store"},{"location":"misc/bible/#chapter-6-the-rites-of-runtime","text":"\"The browser API shall be unified under one name: browser \" You shall scroll with browser.scrollToTop() You shall update the title with browser.setTitle() You shall query not with document.querySelector , but with browser.query()","title":"\u2699\ufe0f Chapter 6: The Rites of Runtime"},{"location":"misc/bible/#chapter-7-the-scroll-of-reuse","text":"\"Thou shalt not copy-paste thy components across projects. Thou shalt jawt add .\" Share JML components through libraries. Use jawt build --as-lib to sanctify them. Let others use them \u2014 if you dare.","title":"\ud83d\udce6 Chapter 7: The Scroll of Reuse"},{"location":"misc/bible/#chapter-8-the-warnings-of-temptation","text":"\"Thou may be tempted to eject the toolchain, to override it, to reach for React.\" You shall not question the compiler. You shall not eject. You shall not say \u201cBut in Vue, I could just\u2014\u201d. JML is law. Jawt is order. JSX is noise.","title":"\ud83d\ude45 Chapter 8: The Warnings of Temptation"},{"location":"misc/bible/#final-words-the-path-of-one","text":"\"Jawt was never meant to be for everyone. It was forged in solitude, to suit the needs of the one.\" But if you walk the path, if you accept the rules, and if you embrace the declarative truth \u2014 you may never write <div class=\"container\"> again. And that, dear pilgrim, is freedom.","title":"\ud83e\uddd9\u200d\u2642\ufe0f Final Words: The Path of One"},{"location":"misc/catch-list/","text":"What You Might Have Missed (Catch List) \u2705 Route metadata per page ( meta block) \u2705 Layout support (wrappers via Layout components) \u2705 Page transitions (planned via built-in <Transition> or router hooks) \u2705 Form validation (planned, maybe with Zod) \u2705 i18n support (planned) \u2705 Theme toggling (via Tailwind and runtime API) \u2705 DevTools overlay (planned in dev server) \u2705 LSP/Editor integration (longer-term roadmap)","title":"Catch List"},{"location":"misc/catch-list/#what-you-might-have-missed-catch-list","text":"\u2705 Route metadata per page ( meta block) \u2705 Layout support (wrappers via Layout components) \u2705 Page transitions (planned via built-in <Transition> or router hooks) \u2705 Form validation (planned, maybe with Zod) \u2705 i18n support (planned) \u2705 Theme toggling (via Tailwind and runtime API) \u2705 DevTools overlay (planned in dev server) \u2705 LSP/Editor integration (longer-term roadmap)","title":"What You Might Have Missed (Catch List)"},{"location":"misc/philosophy/","text":"\ud83e\udded The Philosophy of Jawt \"Jawt is not built to be everything. It is built to be enough.\" \ud83d\udd39 1. Declarative Above All Jawt is built on the principle that you should describe what you want, not how to do it . JML isn\u2019t about imperative logic, control flow, or nested components inside function returns \u2014 it\u2019s about structure, meaning, and clarity . You write what should exist. The compiler handles how it exists. This is the declarative truth. \ud83d\udd39 2. One Way Is Enough In Jawt, everything has a way. One way. Maybe two if the compiler\u2019s in a good mood. No dozens of syntax flavours. No plugin-driven ambiguity. No configuration yoga. \"Options are the enemy of decisions.\" \ud83d\udd39 3. The Compiler Knows Routing? The compiler knows. Component structure? The compiler knows. File types? Imports? Store observation? The compiler knows. You write your intent. Jawt handles the implementation. Trust the compiler. \ud83d\udd39 4. Invisible Complexity Jawt is complex \u2014 but invisibly so. The user does not see the internal Tailwind, the embedded Node, the compiler pipelines. The user sees only the interface: .jml files Declarative structure Live-updating apps Everything else is hidden in .jawt/ , by design. \ud83d\udd39 5. Code Should Feel Like Language JML isn\u2019t a DSL bolted onto JavaScript. It\u2019s a language in its own right. Structured like JSON, expressive like TypeScript Reads like UI poetry Feels like declaration, not configuration You don\u2019t fight the language. You speak it. \ud83d\udd39 6. Zero Config is Sacred No vite.config.js , no tailwind.config.js , no tsconfig.json . Not in your root directory. Not in your face. Jawt handles all that \u2014 inside .jawt/ , where it belongs. You should never have to set up your toolchain just to say \"Hello, World\". \ud83d\udd39 7. Built for One Jawt is not meant for everyone. It is designed for a single user with strong taste \u2014 and maybe a few wanderers who happen to share it. \"It\u2019s not a framework. It\u2019s a belief system with a compiler.\" Jawt doesn\u2019t ask for mass adoption. It asks for alignment. \ud83d\udd39 8. Simplicity is Strictness Simplicity isn\u2019t minimalism. It\u2019s non-negotiable clarity . Jawt removes what\u2019s optional. It eliminates edge-case rituals. It replaces guesswork with structure. There is no freedom in ambiguity \u2014 only chaos. Structure is freedom. \ud83d\udd39 9. Don\u2019t Expose the Machinery The more a developer has to think about how the toolchain works, the more broken the toolchain is. Users of Jawt don\u2019t see the moving parts. They only see the results: Declarative files Self-contained output No setup No clutter \ud83d\udd39 10. Every Project Is a Manifesto Every Jawt app is a declaration. It\u2019s not just code \u2014 it\u2019s structure, flow, state, and logic distilled into something legible, meaningful, and deterministic. You don\u2019t just write with Jawt. You state . You declare . You proclaim . Jawt is a declaration engine disguised as a toolchain. And that is its power. If you believe in structure over sprawl, in declaration over duct tape, and in writing code that reads like it was meant to exist \u2014 then Jawt is already yours.","title":"\ud83e\udded The Philosophy of Jawt"},{"location":"misc/philosophy/#the-philosophy-of-jawt","text":"\"Jawt is not built to be everything. It is built to be enough.\"","title":"\ud83e\udded The Philosophy of Jawt"},{"location":"misc/philosophy/#1-declarative-above-all","text":"Jawt is built on the principle that you should describe what you want, not how to do it . JML isn\u2019t about imperative logic, control flow, or nested components inside function returns \u2014 it\u2019s about structure, meaning, and clarity . You write what should exist. The compiler handles how it exists. This is the declarative truth.","title":"\ud83d\udd39 1. Declarative Above All"},{"location":"misc/philosophy/#2-one-way-is-enough","text":"In Jawt, everything has a way. One way. Maybe two if the compiler\u2019s in a good mood. No dozens of syntax flavours. No plugin-driven ambiguity. No configuration yoga. \"Options are the enemy of decisions.\"","title":"\ud83d\udd39 2. One Way Is Enough"},{"location":"misc/philosophy/#3-the-compiler-knows","text":"Routing? The compiler knows. Component structure? The compiler knows. File types? Imports? Store observation? The compiler knows. You write your intent. Jawt handles the implementation. Trust the compiler.","title":"\ud83d\udd39 3. The Compiler Knows"},{"location":"misc/philosophy/#4-invisible-complexity","text":"Jawt is complex \u2014 but invisibly so. The user does not see the internal Tailwind, the embedded Node, the compiler pipelines. The user sees only the interface: .jml files Declarative structure Live-updating apps Everything else is hidden in .jawt/ , by design.","title":"\ud83d\udd39 4. Invisible Complexity"},{"location":"misc/philosophy/#5-code-should-feel-like-language","text":"JML isn\u2019t a DSL bolted onto JavaScript. It\u2019s a language in its own right. Structured like JSON, expressive like TypeScript Reads like UI poetry Feels like declaration, not configuration You don\u2019t fight the language. You speak it.","title":"\ud83d\udd39 5. Code Should Feel Like Language"},{"location":"misc/philosophy/#6-zero-config-is-sacred","text":"No vite.config.js , no tailwind.config.js , no tsconfig.json . Not in your root directory. Not in your face. Jawt handles all that \u2014 inside .jawt/ , where it belongs. You should never have to set up your toolchain just to say \"Hello, World\".","title":"\ud83d\udd39 6. Zero Config is Sacred"},{"location":"misc/philosophy/#7-built-for-one","text":"Jawt is not meant for everyone. It is designed for a single user with strong taste \u2014 and maybe a few wanderers who happen to share it. \"It\u2019s not a framework. It\u2019s a belief system with a compiler.\" Jawt doesn\u2019t ask for mass adoption. It asks for alignment.","title":"\ud83d\udd39 7. Built for One"},{"location":"misc/philosophy/#8-simplicity-is-strictness","text":"Simplicity isn\u2019t minimalism. It\u2019s non-negotiable clarity . Jawt removes what\u2019s optional. It eliminates edge-case rituals. It replaces guesswork with structure. There is no freedom in ambiguity \u2014 only chaos. Structure is freedom.","title":"\ud83d\udd39 8. Simplicity is Strictness"},{"location":"misc/philosophy/#9-dont-expose-the-machinery","text":"The more a developer has to think about how the toolchain works, the more broken the toolchain is. Users of Jawt don\u2019t see the moving parts. They only see the results: Declarative files Self-contained output No setup No clutter","title":"\ud83d\udd39 9. Don\u2019t Expose the Machinery"},{"location":"misc/philosophy/#10-every-project-is-a-manifesto","text":"Every Jawt app is a declaration. It\u2019s not just code \u2014 it\u2019s structure, flow, state, and logic distilled into something legible, meaningful, and deterministic. You don\u2019t just write with Jawt. You state . You declare . You proclaim . Jawt is a declaration engine disguised as a toolchain. And that is its power. If you believe in structure over sprawl, in declaration over duct tape, and in writing code that reads like it was meant to exist \u2014 then Jawt is already yours.","title":"\ud83d\udd39 10. Every Project Is a Manifesto"},{"location":"misc/vibe/","text":"\ud83d\udd25 The Jawt Vibe Jawt isn\u2019t just a toolchain. It\u2019s a philosophy. It\u2019s opinionated. Unapologetic. Uncompromising. Built for one. Meant for none. Feared by many. If React is a Swiss army knife, Jawt is a handcrafted katana wrapped in strict type safety and righteous declaration. \u2728 It feels like: Writing UI like you\u2019re describing a prophecy, not assembling widgets Coding without drowning in configs, plugins, or build scripts Having your own compiler whisper, \u201cI got this\u201d when you hit save A full-stack of invisible gears moving perfectly behind your single .jml file Web Components and TypeScript doing all the heavy lifting \u2014 quietly, out of sight A spiritual rejection of boilerplate and ceremony \ud83e\uddd8\u200d\u2642\ufe0f It\u2019s for devs who: Want to express ideas, not fight syntax Are tired of pretending useEffect is simple Believe routing should \u201cjust work\u201d when you write a file Think div soup is a modern sin Build for themselves \u2014 not for StackOverflow points \ud83e\uddf1 The Rules: Everything begins with _doctype No node_modules shall touch the user\u2019s soul One way to do things. Maybe two if you bribe the compiler Components are sacred, props are pure Logic is TypeScript, structure is JML If it compiles, it shall live \ud83d\udee0\ufe0f TL;DR: Jawt is a minimalist\u2019s maximalist toolchain. It\u2019s structured, declarative, and deeply personal. It doesn\u2019t want to be popular. It wants to be right . If you get it, you\u2019re home. If you don\u2019t \u2014 there\u2019s always React.","title":"Vibe"},{"location":"misc/vibe/#the-jawt-vibe","text":"Jawt isn\u2019t just a toolchain. It\u2019s a philosophy. It\u2019s opinionated. Unapologetic. Uncompromising. Built for one. Meant for none. Feared by many. If React is a Swiss army knife, Jawt is a handcrafted katana wrapped in strict type safety and righteous declaration.","title":"\ud83d\udd25 The Jawt Vibe"},{"location":"misc/vibe/#it-feels-like","text":"Writing UI like you\u2019re describing a prophecy, not assembling widgets Coding without drowning in configs, plugins, or build scripts Having your own compiler whisper, \u201cI got this\u201d when you hit save A full-stack of invisible gears moving perfectly behind your single .jml file Web Components and TypeScript doing all the heavy lifting \u2014 quietly, out of sight A spiritual rejection of boilerplate and ceremony","title":"\u2728 It feels like:"},{"location":"misc/vibe/#its-for-devs-who","text":"Want to express ideas, not fight syntax Are tired of pretending useEffect is simple Believe routing should \u201cjust work\u201d when you write a file Think div soup is a modern sin Build for themselves \u2014 not for StackOverflow points","title":"\ud83e\uddd8\u200d\u2642\ufe0f It\u2019s for devs who:"},{"location":"misc/vibe/#the-rules","text":"Everything begins with _doctype No node_modules shall touch the user\u2019s soul One way to do things. Maybe two if you bribe the compiler Components are sacred, props are pure Logic is TypeScript, structure is JML If it compiles, it shall live","title":"\ud83e\uddf1 The Rules:"},{"location":"misc/vibe/#tldr","text":"Jawt is a minimalist\u2019s maximalist toolchain. It\u2019s structured, declarative, and deeply personal. It doesn\u2019t want to be popular. It wants to be right . If you get it, you\u2019re home. If you don\u2019t \u2014 there\u2019s always React.","title":"\ud83d\udee0\ufe0f TL;DR:"},{"location":"references/cli/","text":"The JAWT CLI The jawt command-line interface is your main tool for creating, running, and building JAWT applications. Getting Started # Create a new project jawt init my-app # cd into the new directory cd my-app # Start the dev server jawt dev # Build the app for production jawt build Commands init Kicks off a new JAWT project with a default file structure and config files. Usage jawt init <project-name> Arguments Argument Description Required <project-name> The name of the new project directory. Yes Example jawt init my-awesome-app What it Creates my-awesome-app/ \u251c\u2500\u2500 app/ \u2502 \u2514\u2500\u2500 index.jml # Your main page \u251c\u2500\u2500 components/ # For reusable components \u251c\u2500\u2500 assets/ # For static files \u251c\u2500\u2500 app.json # App config \u2514\u2500\u2500 jawt.config.json # JAWT config dev Starts the local development server with hot module replacement (HMR). It watches for changes to your JML files and automatically refreshes your browser. Usage jawt dev [options] Options Option Description Default -p <port> Use a custom port. 6500 -c Start with a clean cache. - Prerequisites You need an app.json and jawt.config.json in your project's root directory. Examples # Start the server on the default port (6500) jawt dev # Start on a different port jawt dev -p 3000 # Start with a clean cache jawt dev -c build Compiles your app or library into a production-ready build. It optimises everything and spits out standard HTML, CSS, and JavaScript. Usage jawt build [options] Options Option Description Default -o <directory> Specify a custom output directory. dist --as-lib Compile the project as a library for reuse. false Examples # Build to the default `dist` directory jawt build # Build to a `public` directory instead jawt build -o public # Build as a library jawt build --as-lib What it Generates HTML : Your compiled JML pages. CSS : Optimised and minified stylesheets. JavaScript : Minified component bundles. WASM : Compiled modules (if you have any). Assets : Your static files, processed and optimized. create page Scaffolds a new JML page with a basic structure. Usage jawt create page <name> Arguments Argument Description Required <name> The name of the new page. Yes Example jawt create page about create component Scaffolds a new JML component with a basic structure. Usage jawt create component <name> Arguments Argument Description Required <name> The name of the new component. Yes Example jawt create component MyButton add Adds a JML component library from a local path or remote repository. Usage jawt add <path/repo> Arguments Argument Description Required <path/repo> The path to the local library or its repository URL. Yes Example jawt add ./my-local-lib jawt add https://github.com/user/some-jawt-lib install Installs npm logic packages for use within Jawt projects. Usage jawt install <pkg> Arguments Argument Description Required <pkg> The name of the npm package to install. Yes Example jawt install lodash Global Options These options work with most commands. Option Description --help Show help for a command. --version Show the JAWT version. Examples jawt --version jawt dev --help jawt build --help","title":"CLI"},{"location":"references/cli/#the-jawt-cli","text":"The jawt command-line interface is your main tool for creating, running, and building JAWT applications.","title":"The JAWT CLI"},{"location":"references/cli/#getting-started","text":"# Create a new project jawt init my-app # cd into the new directory cd my-app # Start the dev server jawt dev # Build the app for production jawt build","title":"Getting Started"},{"location":"references/cli/#commands","text":"","title":"Commands"},{"location":"references/cli/#init","text":"Kicks off a new JAWT project with a default file structure and config files.","title":"init"},{"location":"references/cli/#usage","text":"jawt init <project-name>","title":"Usage"},{"location":"references/cli/#arguments","text":"Argument Description Required <project-name> The name of the new project directory. Yes","title":"Arguments"},{"location":"references/cli/#example","text":"jawt init my-awesome-app","title":"Example"},{"location":"references/cli/#what-it-creates","text":"my-awesome-app/ \u251c\u2500\u2500 app/ \u2502 \u2514\u2500\u2500 index.jml # Your main page \u251c\u2500\u2500 components/ # For reusable components \u251c\u2500\u2500 assets/ # For static files \u251c\u2500\u2500 app.json # App config \u2514\u2500\u2500 jawt.config.json # JAWT config","title":"What it Creates"},{"location":"references/cli/#dev","text":"Starts the local development server with hot module replacement (HMR). It watches for changes to your JML files and automatically refreshes your browser.","title":"dev"},{"location":"references/cli/#usage_1","text":"jawt dev [options]","title":"Usage"},{"location":"references/cli/#options","text":"Option Description Default -p <port> Use a custom port. 6500 -c Start with a clean cache. -","title":"Options"},{"location":"references/cli/#prerequisites","text":"You need an app.json and jawt.config.json in your project's root directory.","title":"Prerequisites"},{"location":"references/cli/#examples","text":"# Start the server on the default port (6500) jawt dev # Start on a different port jawt dev -p 3000 # Start with a clean cache jawt dev -c","title":"Examples"},{"location":"references/cli/#build","text":"Compiles your app or library into a production-ready build. It optimises everything and spits out standard HTML, CSS, and JavaScript.","title":"build"},{"location":"references/cli/#usage_2","text":"jawt build [options]","title":"Usage"},{"location":"references/cli/#options_1","text":"Option Description Default -o <directory> Specify a custom output directory. dist --as-lib Compile the project as a library for reuse. false","title":"Options"},{"location":"references/cli/#examples_1","text":"# Build to the default `dist` directory jawt build # Build to a `public` directory instead jawt build -o public # Build as a library jawt build --as-lib","title":"Examples"},{"location":"references/cli/#what-it-generates","text":"HTML : Your compiled JML pages. CSS : Optimised and minified stylesheets. JavaScript : Minified component bundles. WASM : Compiled modules (if you have any). Assets : Your static files, processed and optimized.","title":"What it Generates"},{"location":"references/cli/#create-page","text":"Scaffolds a new JML page with a basic structure.","title":"create page"},{"location":"references/cli/#usage_3","text":"jawt create page <name>","title":"Usage"},{"location":"references/cli/#arguments_1","text":"Argument Description Required <name> The name of the new page. Yes","title":"Arguments"},{"location":"references/cli/#example_1","text":"jawt create page about","title":"Example"},{"location":"references/cli/#create-component","text":"Scaffolds a new JML component with a basic structure.","title":"create component"},{"location":"references/cli/#usage_4","text":"jawt create component <name>","title":"Usage"},{"location":"references/cli/#arguments_2","text":"Argument Description Required <name> The name of the new component. Yes","title":"Arguments"},{"location":"references/cli/#example_2","text":"jawt create component MyButton","title":"Example"},{"location":"references/cli/#add","text":"Adds a JML component library from a local path or remote repository.","title":"add"},{"location":"references/cli/#usage_5","text":"jawt add <path/repo>","title":"Usage"},{"location":"references/cli/#arguments_3","text":"Argument Description Required <path/repo> The path to the local library or its repository URL. Yes","title":"Arguments"},{"location":"references/cli/#example_3","text":"jawt add ./my-local-lib jawt add https://github.com/user/some-jawt-lib","title":"Example"},{"location":"references/cli/#install","text":"Installs npm logic packages for use within Jawt projects.","title":"install"},{"location":"references/cli/#usage_6","text":"jawt install <pkg>","title":"Usage"},{"location":"references/cli/#arguments_4","text":"Argument Description Required <pkg> The name of the npm package to install. Yes","title":"Arguments"},{"location":"references/cli/#example_4","text":"jawt install lodash","title":"Example"},{"location":"references/cli/#global-options","text":"These options work with most commands. Option Description --help Show help for a command. --version Show the JAWT version.","title":"Global Options"},{"location":"references/cli/#examples_2","text":"jawt --version jawt dev --help jawt build --help","title":"Examples"},{"location":"references/components/","text":"","title":"Components"},{"location":"references/pages/","text":"","title":"Pages"},{"location":"resources/contributing/","text":"","title":"Contributing"},{"location":"resources/faq/","text":"Frequently Asked Questions","title":"FAQ"},{"location":"resources/faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"resources/migration/","text":"","title":"Migration"},{"location":"runtime/","text":"Runtime Architecture Pages : Compiled into custom elements like <page-home> , injected into <router-view> Routing : SPA model, powered by Vaadin Router, dynamic lazy-loading via import() State : Managed via NanoStores, scoped per feature Runtime APIs : browser : DOM & BOM helpers store : Unified client-side persistence clipboard , env , events , network , date , etc. Logic & Scripts : Written in .ts , imported into components Built-in Component Library (Lit-based) Included out of the box: Button , Input , Text , Card , Container , Grid , List , Modal , Form , Header , Footer , RouterView These can be extended, overridden, or ignored in favour of user libraries. Built-in Runtime APIs (TypeScript) These modules are embedded into Jawt and available from any .jml file: Module Functions browser query() , setTitle() , scrollToTop() store get() , set() , clear() , observe() events emit() , on() , off() clipboard copy() , paste() network fetch() , getJSON() , post() date now() , format() , parse() env isProd() , getEnv()","title":"Overview"},{"location":"runtime/#runtime-architecture","text":"Pages : Compiled into custom elements like <page-home> , injected into <router-view> Routing : SPA model, powered by Vaadin Router, dynamic lazy-loading via import() State : Managed via NanoStores, scoped per feature Runtime APIs : browser : DOM & BOM helpers store : Unified client-side persistence clipboard , env , events , network , date , etc. Logic & Scripts : Written in .ts , imported into components","title":"Runtime Architecture"},{"location":"runtime/#built-in-component-library-lit-based","text":"Included out of the box: Button , Input , Text , Card , Container , Grid , List , Modal , Form , Header , Footer , RouterView These can be extended, overridden, or ignored in favour of user libraries.","title":"Built-in Component Library (Lit-based)"},{"location":"runtime/#built-in-runtime-apis-typescript","text":"These modules are embedded into Jawt and available from any .jml file: Module Functions browser query() , setTitle() , scrollToTop() store get() , set() , clear() , observe() events emit() , on() , off() clipboard copy() , paste() network fetch() , getJSON() , post() date now() , format() , parse() env isProd() , getEnv()","title":"Built-in Runtime APIs (TypeScript)"},{"location":"testing/","text":"Testing & Debugging Compiler outputs debug info to .jawt/generated/ Dev server supports HMR + browser error overlay (Planned) Golden file tests for compiler validation (Planned) CLI test runner for component logic","title":"Overview"},{"location":"testing/#testing-debugging","text":"Compiler outputs debug info to .jawt/generated/ Dev server supports HMR + browser error overlay (Planned) Golden file tests for compiler validation (Planned) CLI test runner for component logic","title":"Testing &amp; Debugging"},{"location":"tutorial/first-page/","text":"Your First JAWT Page This is your \"Hello, World!\" for JAWT. We'll create a simple web page using JML and some of the built-in components. No complex stuff, just the basics to get you started. What You'll Learn How to create a new JAWT project. The basic structure of a JML page. How to use built-in components like Container , Text , and Button . How to apply styles with Tailwind CSS. Prerequisites You'll need JAWT installed. A basic understanding of HTML and CSS will be helpful. Setting Up the Project First, let's create a new project. jawt init my-first-page cd my-first-page This will give you a basic project structure: my-first-page/ \u251c\u2500\u2500 app/ \u2502 \u2514\u2500\u2500 index.jml # This is where we'll work \u251c\u2500\u2500 components/ # For later \u251c\u2500\u2500 assets/ # For images, etc. \u251c\u2500\u2500 app.json # Project config \u2514\u2500\u2500 jawt.config.json # Build config The Anatomy of a JML Page Every JML page has a simple, predictable structure. _doctype page pageName Page { title: \"Page Title\" description: \"A description of the page\" // You can only have one component directly inside a Page Container { // The rest of your page content goes here } } The Key Parts _doctype page pageName : This tells JAWT to compile this file into an HTML page. Page : A special component that holds metadata and the content of your page. A Single Root Component : You can only have one component directly inside Page . Usually, this is a Container . Let's Build Something Open up app/index.jml and replace its content with this: _doctype page welcome Page { title: \"Welcome to JAWT\" description: \"My first JAWT page using JML\" Container { style: \"min-h-screen bg-gray-50 flex flex-col items-center justify-center p-8\" Text { text: \"Hello, JAWT!\" style: \"text-4xl font-bold text-blue-600 mb-4\" } Text { text: \"This is my first page built with JML.\" style: \"text-lg text-gray-700 mb-8 text-center\" } Button { text: \"Welcome Button\" style: \"bg-blue-500 hover:bg-blue-600 text-white px-6 py-2 rounded-lg shadow-md transition-colors\" } } } The Built-in Components JAWT gives you a few basic components to start with. Container This is your basic <div> . It's for grouping other elements. Container { style: \"flex flex-col space-y-4 p-6\" // Other components go here } Text This is for displaying text. Think of it as a <p> or <h1> tag. Text { text: \"Some text here.\" style: \"text-xl font-semibold text-gray-800\" } Button This creates a clickable button. Button { text: \"Click me!\" style: \"bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600\" } Styling with Tailwind CSS JAWT is set up to use Tailwind CSS for styling. You just add a style property with Tailwind's utility classes. Container { style: \"bg-white shadow-lg rounded-lg p-6 max-w-md mx-auto\" } A More Complete Example Let's make a slightly more interesting page. _doctype page portfolio Page { title: \"My Portfolio\" description: \"A simple portfolio page built with JAWT\" favicon: \"/favicon.ico\" Container { style: \"min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100\" Container { style: \"max-w-4xl mx-auto p-8\" Text { text: \"John Doe\" style: \"text-5xl font-bold text-gray-800 text-center mb-2\" } Text { text: \"Web Developer & Designer\" style: \"text-xl text-gray-600 text-center mb-8\" } Container { style: \"bg-white rounded-xl shadow-lg p-8 mb-8\" Text { text: \"About Me\" style: \"text-2xl font-semibold text-gray-800 mb-4\" } Text { text: \"I'm passionate about creating beautiful, functional web experiences using modern tools and technologies. JAWT allows me to build fast, efficient websites with clean, declarative code.\" style: \"text-gray-700 leading-relaxed mb-6\" } Button { text: \"View My Work\" style: \"bg-blue-500 hover:bg-blue-600 text-white px-6 py-3 rounded-lg font-medium transition-colors shadow-md\" } } } } } See It in Action To see your page, run the dev server: # Start the dev server jawt run Your page will be running at http://localhost:6500 . The server has hot reloading, so any changes you make to the JML file will show up in the browser instantly. Page Properties The Page component has a few properties you can set: Page { title: \"Page Title\" // The <title> tag description: \"Page description\" // The meta description favicon: \"/favicon.ico\" // The favicon name: \"internal-page-name\" // An internal name for the page keywords: \"keyword1, keyword2\" // SEO keywords author: \"Your Name\" // The author of the page viewport: \"width=device-width, initial-scale=1.0\" // Viewport settings // Your page content Container { // ... } } Building for Production When you're ready to deploy your page, just run: # Create an optimized build jawt build This will create a dist/ directory with your compiled page, ready to be uploaded to any web server. Key Takeaways JML is declarative : You describe the \"what,\" not the \"how.\" Pages have a single root component : Usually a Container . Built-in components are your friends : Container , Text , and Button are great starting points. Styling is done with Tailwind : Use the style property. Hot reload is awesome : See your changes instantly. What's Next? Now that you've built a basic page, you can explore: Creating your own reusable components. Adding interactivity with TypeScript. Building multi-page apps with routing. Congrats! You've built your first page with JAWT. You now know the fundamentals for building much more complex applications.","title":"First Page"},{"location":"tutorial/first-page/#your-first-jawt-page","text":"This is your \"Hello, World!\" for JAWT. We'll create a simple web page using JML and some of the built-in components. No complex stuff, just the basics to get you started.","title":"Your First JAWT Page"},{"location":"tutorial/first-page/#what-youll-learn","text":"How to create a new JAWT project. The basic structure of a JML page. How to use built-in components like Container , Text , and Button . How to apply styles with Tailwind CSS.","title":"What You'll Learn"},{"location":"tutorial/first-page/#prerequisites","text":"You'll need JAWT installed. A basic understanding of HTML and CSS will be helpful.","title":"Prerequisites"},{"location":"tutorial/first-page/#setting-up-the-project","text":"First, let's create a new project. jawt init my-first-page cd my-first-page This will give you a basic project structure: my-first-page/ \u251c\u2500\u2500 app/ \u2502 \u2514\u2500\u2500 index.jml # This is where we'll work \u251c\u2500\u2500 components/ # For later \u251c\u2500\u2500 assets/ # For images, etc. \u251c\u2500\u2500 app.json # Project config \u2514\u2500\u2500 jawt.config.json # Build config","title":"Setting Up the Project"},{"location":"tutorial/first-page/#the-anatomy-of-a-jml-page","text":"Every JML page has a simple, predictable structure. _doctype page pageName Page { title: \"Page Title\" description: \"A description of the page\" // You can only have one component directly inside a Page Container { // The rest of your page content goes here } }","title":"The Anatomy of a JML Page"},{"location":"tutorial/first-page/#the-key-parts","text":"_doctype page pageName : This tells JAWT to compile this file into an HTML page. Page : A special component that holds metadata and the content of your page. A Single Root Component : You can only have one component directly inside Page . Usually, this is a Container .","title":"The Key Parts"},{"location":"tutorial/first-page/#lets-build-something","text":"Open up app/index.jml and replace its content with this: _doctype page welcome Page { title: \"Welcome to JAWT\" description: \"My first JAWT page using JML\" Container { style: \"min-h-screen bg-gray-50 flex flex-col items-center justify-center p-8\" Text { text: \"Hello, JAWT!\" style: \"text-4xl font-bold text-blue-600 mb-4\" } Text { text: \"This is my first page built with JML.\" style: \"text-lg text-gray-700 mb-8 text-center\" } Button { text: \"Welcome Button\" style: \"bg-blue-500 hover:bg-blue-600 text-white px-6 py-2 rounded-lg shadow-md transition-colors\" } } }","title":"Let's Build Something"},{"location":"tutorial/first-page/#the-built-in-components","text":"JAWT gives you a few basic components to start with.","title":"The Built-in Components"},{"location":"tutorial/first-page/#container","text":"This is your basic <div> . It's for grouping other elements. Container { style: \"flex flex-col space-y-4 p-6\" // Other components go here }","title":"Container"},{"location":"tutorial/first-page/#text","text":"This is for displaying text. Think of it as a <p> or <h1> tag. Text { text: \"Some text here.\" style: \"text-xl font-semibold text-gray-800\" }","title":"Text"},{"location":"tutorial/first-page/#button","text":"This creates a clickable button. Button { text: \"Click me!\" style: \"bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600\" }","title":"Button"},{"location":"tutorial/first-page/#styling-with-tailwind-css","text":"JAWT is set up to use Tailwind CSS for styling. You just add a style property with Tailwind's utility classes. Container { style: \"bg-white shadow-lg rounded-lg p-6 max-w-md mx-auto\" }","title":"Styling with Tailwind CSS"},{"location":"tutorial/first-page/#a-more-complete-example","text":"Let's make a slightly more interesting page. _doctype page portfolio Page { title: \"My Portfolio\" description: \"A simple portfolio page built with JAWT\" favicon: \"/favicon.ico\" Container { style: \"min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100\" Container { style: \"max-w-4xl mx-auto p-8\" Text { text: \"John Doe\" style: \"text-5xl font-bold text-gray-800 text-center mb-2\" } Text { text: \"Web Developer & Designer\" style: \"text-xl text-gray-600 text-center mb-8\" } Container { style: \"bg-white rounded-xl shadow-lg p-8 mb-8\" Text { text: \"About Me\" style: \"text-2xl font-semibold text-gray-800 mb-4\" } Text { text: \"I'm passionate about creating beautiful, functional web experiences using modern tools and technologies. JAWT allows me to build fast, efficient websites with clean, declarative code.\" style: \"text-gray-700 leading-relaxed mb-6\" } Button { text: \"View My Work\" style: \"bg-blue-500 hover:bg-blue-600 text-white px-6 py-3 rounded-lg font-medium transition-colors shadow-md\" } } } } }","title":"A More Complete Example"},{"location":"tutorial/first-page/#see-it-in-action","text":"To see your page, run the dev server: # Start the dev server jawt run Your page will be running at http://localhost:6500 . The server has hot reloading, so any changes you make to the JML file will show up in the browser instantly.","title":"See It in Action"},{"location":"tutorial/first-page/#page-properties","text":"The Page component has a few properties you can set: Page { title: \"Page Title\" // The <title> tag description: \"Page description\" // The meta description favicon: \"/favicon.ico\" // The favicon name: \"internal-page-name\" // An internal name for the page keywords: \"keyword1, keyword2\" // SEO keywords author: \"Your Name\" // The author of the page viewport: \"width=device-width, initial-scale=1.0\" // Viewport settings // Your page content Container { // ... } }","title":"Page Properties"},{"location":"tutorial/first-page/#building-for-production","text":"When you're ready to deploy your page, just run: # Create an optimized build jawt build This will create a dist/ directory with your compiled page, ready to be uploaded to any web server.","title":"Building for Production"},{"location":"tutorial/first-page/#key-takeaways","text":"JML is declarative : You describe the \"what,\" not the \"how.\" Pages have a single root component : Usually a Container . Built-in components are your friends : Container , Text , and Button are great starting points. Styling is done with Tailwind : Use the style property. Hot reload is awesome : See your changes instantly.","title":"Key Takeaways"},{"location":"tutorial/first-page/#whats-next","text":"Now that you've built a basic page, you can explore: Creating your own reusable components. Adding interactivity with TypeScript. Building multi-page apps with routing. Congrats! You've built your first page with JAWT. You now know the fundamentals for building much more complex applications.","title":"What's Next?"}]}