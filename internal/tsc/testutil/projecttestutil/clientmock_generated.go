// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package projecttestutil

import (
	"context"
	"sync"

	"github.com/yasufadhili/jawt/internal/tsc/lsp/lsproto"
	"github.com/yasufadhili/jawt/internal/tsc/project"
)

// Ensure, that ClientMock does implement project.Client.
// If this is not the case, regenerate this file with moq.
var _ project.Client = &ClientMock{}

// ClientMock is a mock implementation of project.Client.
//
//	func TestSomethingThatUsesClient(t *testing.T) {
//
//		// make and configure a mocked project.Client
//		mockedClient := &ClientMock{
//			RefreshDiagnosticsFunc: func(ctx context.Context) error {
//				panic("mock out the RefreshDiagnostics method")
//			},
//			UnwatchFilesFunc: func(ctx context.Context, handle project.WatcherHandle) error {
//				panic("mock out the UnwatchFiles method")
//			},
//			WatchFilesFunc: func(ctx context.Context, watchers []*lsproto.FileSystemWatcher) (project.WatcherHandle, error) {
//				panic("mock out the WatchFiles method")
//			},
//		}
//
//		// use mockedClient in code that requires project.Client
//		// and then make assertions.
//
//	}
type ClientMock struct {
	// RefreshDiagnosticsFunc mocks the RefreshDiagnostics method.
	RefreshDiagnosticsFunc func(ctx context.Context) error

	// UnwatchFilesFunc mocks the UnwatchFiles method.
	UnwatchFilesFunc func(ctx context.Context, handle project.WatcherHandle) error

	// WatchFilesFunc mocks the WatchFiles method.
	WatchFilesFunc func(ctx context.Context, watchers []*lsproto.FileSystemWatcher) (project.WatcherHandle, error)

	// calls tracks calls to the methods.
	calls struct {
		// RefreshDiagnostics holds details about calls to the RefreshDiagnostics method.
		RefreshDiagnostics []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// UnwatchFiles holds details about calls to the UnwatchFiles method.
		UnwatchFiles []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Handle is the handle argument value.
			Handle project.WatcherHandle
		}
		// WatchFiles holds details about calls to the WatchFiles method.
		WatchFiles []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Watchers is the watchers argument value.
			Watchers []*lsproto.FileSystemWatcher
		}
	}
	lockRefreshDiagnostics sync.RWMutex
	lockUnwatchFiles       sync.RWMutex
	lockWatchFiles         sync.RWMutex
}

// RefreshDiagnostics calls RefreshDiagnosticsFunc.
func (mock *ClientMock) RefreshDiagnostics(ctx context.Context) error {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockRefreshDiagnostics.Lock()
	mock.calls.RefreshDiagnostics = append(mock.calls.RefreshDiagnostics, callInfo)
	mock.lockRefreshDiagnostics.Unlock()
	if mock.RefreshDiagnosticsFunc == nil {
		var errOut error
		return errOut
	}
	return mock.RefreshDiagnosticsFunc(ctx)
}

// RefreshDiagnosticsCalls gets all the calls that were made to RefreshDiagnostics.
// Check the length with:
//
//	len(mockedClient.RefreshDiagnosticsCalls())
func (mock *ClientMock) RefreshDiagnosticsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockRefreshDiagnostics.RLock()
	calls = mock.calls.RefreshDiagnostics
	mock.lockRefreshDiagnostics.RUnlock()
	return calls
}

// UnwatchFiles calls UnwatchFilesFunc.
func (mock *ClientMock) UnwatchFiles(ctx context.Context, handle project.WatcherHandle) error {
	callInfo := struct {
		Ctx    context.Context
		Handle project.WatcherHandle
	}{
		Ctx:    ctx,
		Handle: handle,
	}
	mock.lockUnwatchFiles.Lock()
	mock.calls.UnwatchFiles = append(mock.calls.UnwatchFiles, callInfo)
	mock.lockUnwatchFiles.Unlock()
	if mock.UnwatchFilesFunc == nil {
		var errOut error
		return errOut
	}
	return mock.UnwatchFilesFunc(ctx, handle)
}

// UnwatchFilesCalls gets all the calls that were made to UnwatchFiles.
// Check the length with:
//
//	len(mockedClient.UnwatchFilesCalls())
func (mock *ClientMock) UnwatchFilesCalls() []struct {
	Ctx    context.Context
	Handle project.WatcherHandle
} {
	var calls []struct {
		Ctx    context.Context
		Handle project.WatcherHandle
	}
	mock.lockUnwatchFiles.RLock()
	calls = mock.calls.UnwatchFiles
	mock.lockUnwatchFiles.RUnlock()
	return calls
}

// WatchFiles calls WatchFilesFunc.
func (mock *ClientMock) WatchFiles(ctx context.Context, watchers []*lsproto.FileSystemWatcher) (project.WatcherHandle, error) {
	callInfo := struct {
		Ctx      context.Context
		Watchers []*lsproto.FileSystemWatcher
	}{
		Ctx:      ctx,
		Watchers: watchers,
	}
	mock.lockWatchFiles.Lock()
	mock.calls.WatchFiles = append(mock.calls.WatchFiles, callInfo)
	mock.lockWatchFiles.Unlock()
	if mock.WatchFilesFunc == nil {
		var (
			watcherHandleOut project.WatcherHandle
			errOut           error
		)
		return watcherHandleOut, errOut
	}
	return mock.WatchFilesFunc(ctx, watchers)
}

// WatchFilesCalls gets all the calls that were made to WatchFiles.
// Check the length with:
//
//	len(mockedClient.WatchFilesCalls())
func (mock *ClientMock) WatchFilesCalls() []struct {
	Ctx      context.Context
	Watchers []*lsproto.FileSystemWatcher
} {
	var calls []struct {
		Ctx      context.Context
		Watchers []*lsproto.FileSystemWatcher
	}
	mock.lockWatchFiles.RLock()
	calls = mock.calls.WatchFiles
	mock.lockWatchFiles.RUnlock()
	return calls
}
